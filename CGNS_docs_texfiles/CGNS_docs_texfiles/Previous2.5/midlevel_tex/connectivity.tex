\section{Grid Connectivity}
\label{s:connectivity}
\thispagestyle{plain}

\subsection{One-to-One Connectivity}
\label{s:1to1}

\noindent
\textit{Node}: \texttt{GridConnectivity1to1\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_n1to1\_global(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{int *n1to1\_global}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_read\_global(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{char **connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{char **zonename}}, \textcolor{output}{\textit{char **donorname}}, \textcolor{output}{\textit{int **range}}, & \\
~~~~~~\textcolor{output}{\textit{int **donor\_range}}, \textcolor{output}{\textit{int **transform}}); & \\
\hline
call cg\_n1to1\_global\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{n1to1\_global}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_read\_global\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{zonename}}, \textcolor{output}{\textit{donorname}}, & r - m \\
~~~~~\textcolor{output}{\textit{range}}, \textcolor{output}{\textit{donor\_range}}, \textcolor{output}{\textit{transform}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{n1to1\_global}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{n1to1\_global}]
      Total number of one-to-one interfaces in base \texttt{B},
      stored under \texttt{GridConnectivity1to1\_t} nodes.
      (I.e., this does not include one-to-one interfaces that may be
      stored under \texttt{GridConnectivity\_t} nodes, used for
      generalized zone interfaces.)
      Note that the function \texttt{cg\_n1to1} (described below) may be
      used to get the number of one-to-one interfaces in a specific
      zone.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{connectname}]
      Name of the interface.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{zonename}]
      Name of the first zone, for all one-to-one interfaces in base
      \texttt{B}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{donorname}]
      Name of the second zone, for all one-to-one interfaces in base
      \texttt{B}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{range}]
      Range of points for the first zone, for all one-to-one interfaces
      in base \texttt{B}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{donor\_range}]
      Range of points for the current zone, for all one-to-one interfaces
      in base \texttt{B}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{transform}]
      Short hand notation for the transformation matrix defining the
      relative orientation of the two zones.
      This transformation is given for all one-to-one interfaces in
      base \texttt{B}.
      See the description of \texttt{GridConnectivity1to1\_t} in the
      \href{../sids/sids.pdf}{SIDS manual} for details.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions may be used to get information about all the
one-to-one zone interfaces in a CGNS database.

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_1to1\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{char *donorname}, \textcolor{input}{int *range}, \textcolor{input}{int *donor\_range}, \textcolor{input}{int *transform}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_n1to1(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *n1to1}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{char *donorname}}, \textcolor{output}{\textit{int *range}}, \textcolor{output}{\textit{int *donor\_range}}, \textcolor{output}{\textit{int *transform}}); & \\
\hline
call cg\_1to1\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{donorname}, \textcolor{input}{range}, & - w m \\
~~~~~\textcolor{input}{donor\_range}, \textcolor{input}{transform}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_n1to1\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{n1to1}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{donorname}}, \textcolor{output}{\textit{range}}, & r - m \\
~~~~~\textcolor{output}{\textit{donor\_range}}, \textcolor{output}{\textit{transform}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{connectname}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{I}]
      Interface index number, where $1 \leq \text{\texttt{I}} \leq \text{\texttt{n1to1}}$.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_write})
\item [\texttt{n1to1}]
      Number of one-to-one interfaces in zone \texttt{Z}, stored under
      \texttt{GridConnectivity1to1\_t} nodes.
      (I.e., this does not include one-to-one interfaces that may be
      stored under \texttt{GridConnectivity\_t} nodes, used for
      generalized zone interfaces.)
      (\textcolor{output}{\textit{Output}})
\item [\texttt{connectname}]
      Name of the interface.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_read})
\item [\texttt{donorname}]
      Name of the zone interfacing with the current zone.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_read})
\item [\texttt{range}]
      Range of points for the current zone.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_read})
\item [\texttt{donor\_range}]
      Range of points for the donor zone.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_read})
\item [\texttt{transform}]
      Short hand notation for the transformation matrix defining the
      relative orientation of the two zones.
      See the description of \texttt{GridConnectivity1to1\_t} in the
      \href{../sids/sids.pdf}{SIDS manual} for details.
      (\textcolor{input}{Input} for \texttt{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_1to1\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions are used to read and write one-to-one connectivity
data for a specific zone.

\newpage
\subsection{Generalized Connectivity}
\label{s:generalized}

\noindent
\textit{Node}: \texttt{GridConnectivity\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_conn\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{GridConnectivityType\_t connect\_type}, & \\
~~~~~~\textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{input}{char *donorname}, & \\
~~~~~~\textcolor{input}{ZoneType\_t donor\_zonetype}, \textcolor{input}{PointSetType\_t donor\_ptset\_type}, & \\
~~~~~~\textcolor{input}{DataType\_t donor\_datatype}, \textcolor{input}{int ndata\_donor}, \textcolor{input}{void *donor\_data}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_write\_short(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{GridConnectivityType\_t connect\_type}, & \\
~~~~~~\textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{input}{char *donorname}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nconns(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nconns}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_conn\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{GridLocation\_t *location}}, \textcolor{output}{\textit{GridConnectivityType\_t *connect\_type}}, & \\
~~~~~~\textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, \textcolor{output}{\textit{int *npnts}}, \textcolor{output}{\textit{char *donorname}}, & \\
~~~~~~\textcolor{output}{\textit{ZoneType\_t *donor\_zonetype}}, \textcolor{output}{\textit{PointSetType\_t *donor\_ptset\_type}}, & \\
~~~~~~\textcolor{output}{\textit{DataType\_t *donor\_datatype}}, \textcolor{output}{\textit{int *ndata\_donor}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{int *pnts}}, & r - m \\
~~~~~~\textcolor{input}{DataType\_t donor\_datatype}, \textcolor{output}{\textit{void *donor\_data}}); & \\
\hline
call cg\_conn\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{location}, \textcolor{input}{connect\_type}, & - w m \\
~~~~~\textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{input}{donorname}, \textcolor{input}{donor\_zonetype}, & \\
~~~~~\textcolor{input}{donor\_ptset\_type}, \textcolor{input}{donor\_datatype}, \textcolor{input}{ndata\_donor}, \textcolor{input}{donor\_data}, \textcolor{output}{\textit{I}}, & \\
~~~~~\textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_write\_short\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{location}, & - w m \\
~~~~~\textcolor{input}{connect\_type}, \textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{input}{donorname}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_nconns\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nconns}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_conn\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{location}}, \textcolor{output}{\textit{connect\_type}}, & r - m \\
~~~~~\textcolor{output}{\textit{ptset\_type}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{donorname}}, \textcolor{output}{\textit{donor\_zonetype}}, \textcolor{output}{\textit{donor\_ptset\_type}}, & \\
~~~~~\textcolor{output}{\textit{donor\_datatype}}, \textcolor{output}{\textit{ndata\_donor}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{pnts}}, \textcolor{input}{donor\_datatype}, \textcolor{output}{\textit{donor\_data}}, & r - m \\
~~~~~\textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{donor\_ptset\_type}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{I}]
      Discrete data index number, where $1 \leq \text{\texttt{I}} \leq \text{\texttt{nconns}}$.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_info},
      \texttt{cg\_conn\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short})
\item [\texttt{nconns}]
      Number of interfaces for zone \texttt{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{connectname}]
      Name of the interface.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{location}]
      Grid location used in the definition of the point set.
      The currently admissible locations are \texttt{Vertex} and
      \texttt{CellCenter}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{connect\_type}]
      Type of interface being defined.
      The admissible types are \texttt{Overset}, \texttt{Abutting},
      and \texttt{Abutting1to1}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{ptset\_type}]
      Type of point set defining the interface in the current zone;
      either \texttt{PointRange} or \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{donor\_ptset\_type}]
      Type of point set defining the interface in the donor zone;
      either \texttt{PointListDonor} or \texttt{CellListDonor}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{npnts}]
      Number of points defining the interface in the current zone.
      For a \texttt{ptset\_type} of \texttt{PointRange}, \texttt{npnts}
      is always two.
      For a \texttt{ptset\_type} of \texttt{PointList}, \texttt{npnts} is
      the number of points in the \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{ndata\_donor}]
      Number of points or cells in the current zone.
      These are paired with points, cells, or fractions thereof in the
      donor zone.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{donorname}]
      Name of the zone interfacing with the current zone.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{donor\_datatype}]
      Data type in which the donor points are stored in the file.
      The only admissible type, as of version 2.0 of the Mid-Level
      Library, is \texttt{Integer}.
      The \texttt{donor\_datatype} argument was left in these functions
      only for backward compatibility.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{pnts}]
      Array of points defining the interface in the current zone.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write},
      \texttt{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_read})
\item [\texttt{donor\_data}]
      Array of donor points or cells corresponding to
      \texttt{ndata\_donor}.
      Note that it is possible that the same donor point or cell may
      be used multiple times.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_read})
\item [\texttt{donor\_zonetype}]
      Type of the donor zone.
      The admissible types are \texttt{Structured} and \texttt{Unstructured}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_info})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

Note that the interpolation factors stored
in the \texttt{InterpolantsDonor} data array are accessed using the
\texttt{cg\_goto} and \texttt{cg\_array\_\textit{xxx}} functions, described
in \autoref{s:navigating} and \autoref{s:dataarray}, respectively.

\newpage
\subsection{Special Grid Connectivity Properties}
\label{s:connproperty}

\noindent
\textit{Node}: \texttt{GridConnectivityProperty\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_conn\_periodic\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{float *RotationCenter}, \textcolor{input}{float *RotationAngle}, \textcolor{input}{float *Translation}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_average\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{AverageInterfaceType\_t AverageInterfaceType}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_periodic\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{float *RotationCenter}, \textcolor{input}{float *RotationAngle}, \textcolor{input}{float *Translation}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_average\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{AverageInterfaceType\_t AverageInterfaceType}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_periodic\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{float *RotationCenter}}, \textcolor{output}{\textit{float *RotationAngle}}, & \\
~~~~~~\textcolor{output}{\textit{float *Translation}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_average\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{AverageInterfaceType\_t *AverageInterfaceType}}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_periodic\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{float *RotationCenter}}, \textcolor{output}{\textit{float *RotationAngle}}, & \\
~~~~~~\textcolor{output}{\textit{float *Translation}}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_average\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{AverageInterfaceType\_t *AverageInterfaceType}}); & \\
\hline
call cg\_conn\_periodic\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{RotationCenter}, & - w m \\
~~~~~\textcolor{input}{RotationAngle}, \textcolor{input}{Translation}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_average\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{AverageInterfaceType}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_1to1\_periodic\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{RotationCenter}, & - w m \\
~~~~~\textcolor{input}{RotationAngle}, \textcolor{input}{Translation}, \textcolor{output}{\textit{ier}}) & \\
call cg\_1to1\_average\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{AverageInterfaceType}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_conn\_periodic\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{RotationCenter}}, & r - m \\
~~~~~\textcolor{output}{\textit{RotationAngle}}, \textcolor{output}{\textit{Translation}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_average\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{AverageInterfaceType}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_periodic\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{RotationCenter}}, & r - m \\
~~~~~\textcolor{output}{\textit{RotationAngle}}, \textcolor{output}{\textit{Translation}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_1to1\_average\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{AverageInterfaceType}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{AverageInterfaceType}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{I}]
      Grid connectivity index number, where
      $1 \leq \text{\texttt{I}} \leq \text{\texttt{nconns}}$
      for the ``\texttt{cg\_conn}'' functions, and
      $1 \leq \text{\texttt{I}} \leq \text{\texttt{n1to1}}$
      for the ``\texttt{cg\_1to1}'' functions.
      (\textcolor{input}{Input})
\item [\texttt{RotationCenter}]
      An array of size \texttt{phys\_dim} defining the coordinates of
      the origin for defining the rotation angle between the periodic
      interfaces.
      (\texttt{phys\_dim} is the number of coordinates required to define
      a vector in the field.)
      (\textcolor{input}{Input} for \texttt{cg\_conn\_periodic\_write},
      \texttt{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_periodic\_read},
      \texttt{cg\_1to1\_periodic\_read})
\item [\texttt{RotationAngle}]
      An array of size \texttt{phys\_dim} defining the rotation angle from
      the current interface to the connecting interface.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_periodic\_write},
      \texttt{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_periodic\_read},
      \texttt{cg\_1to1\_periodic\_read})
\item [\texttt{Translation}]
      An array of size \texttt{phys\_dim} defining the translation from
      the current interface to the connecting interface.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_periodic\_write},
      \texttt{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_periodic\_read},
      \texttt{cg\_1to1\_periodic\_read})
\item [\texttt{AverageInterfaceType}]
      The type of averaging to be done.
      Valid types are \texttt{Null}, \texttt{UserDefined}, \texttt{AverageAll},
      \texttt{AverageCircumferential}, \texttt{AverageRadial}, \texttt{AverageI},
      \texttt{AverageJ}, and \texttt{AverageK}.
      (\textcolor{input}{Input} for \texttt{cg\_conn\_average\_write},
      \texttt{cg\_1to1\_average\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_conn\_average\_read},
      \texttt{cg\_1to1\_average\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

These functions may be used to store special grid connectivity properties.
The ``\texttt{cg\_conn}'' functions apply to generalized grid
connectivity nodes (i.e., \texttt{GridConnectivity\_t}), and the
``\texttt{cg\_1to1}'' functions apply to 1-to-1 grid connectivity nodes
(i.e., \texttt{GridConnectivity1to1\_t}).

The ``\texttt{write}'' functions will create the
\texttt{GridConnectivityProperty\_t} node if it doesn't already exist,
then add the appropriate connectivity property.
Multiple connectivity properties may be recorded under the same
\texttt{GridConnectivityProperty\_t} node.

The ``\texttt{read}'' functions will return with $\text{\texttt{ier}} = 2 =
\text{\texttt{CG\_NODE\_NOT\_FOUND}}$ if the requested connectivity property,
or the \texttt{GridConnectivityProperty\_t} node itself, doesn't exist.

\newpage
\subsection{Overset Holes}
\label{s:overset}

\noindent
\textit{Node}: \texttt{OversetHoles\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_hole\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *holename}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int nptsets}, & \\
~~~~~~\textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nholes(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nholes}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_hole\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *holename}}, & r - m \\
~~~~~~\textcolor{output}{\textit{GridLocation\_t *location}}, \textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, & \\
~~~~~~\textcolor{output}{\textit{int *nptsets}}, \textcolor{output}{\textit{int *npnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_hole\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{int *pnts}}); & r - m \\
\hline
call cg\_hole\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{holename}, \textcolor{input}{location}, \textcolor{input}{ptset\_type}, & - w m \\
~~~~~\textcolor{input}{nptsets}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_nholes\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nholes}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_hole\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{holename}}, \textcolor{output}{\textit{location}}, \textcolor{output}{\textit{ptset\_type}}, & r - m \\
~~~~~\textcolor{output}{\textit{nptsets}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_hole\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{pnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{ptset\_type}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{I}]
      Overset hole index number, where $1 \leq \text{\texttt{I}} \leq \text{\texttt{nholes}}$.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_info},
      \texttt{cg\_hole\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_write})
\item [\texttt{nholes}]
      Number of overset holes in zone \texttt{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{holename}]
      Name of the overset hole.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_info})
\item [\texttt{location}]
      Grid location used in the definition of the point set.
      The currently admissible locations are \texttt{Vertex} and
      \texttt{CellCenter}.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_info})
\item [\texttt{ptset\_type}]
      The extent of the overset hole may be defined using a range of
      points or cells, or using a discrete list of all points or cells
      in the overset hole.
      If a range of points or cells is used, \texttt{ptset\_type} is set
      to \texttt{PointRange}.
      When a discrete list of points or cells is used,
      \texttt{ptset\_type} equals \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_info})
\item [\texttt{nptsets}]
      Number of point sets used to define the hole.
      If \texttt{ptset\_type} is \texttt{PointRange}, several point sets
      may be used.
      If \texttt{ptset\_type} is \texttt{PointList}, only one point set
      is allowed.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_info})
\item [\texttt{npnts}]
      Number of points (or cells) in the point set.
      For a \texttt{ptset\_type} of \texttt{PointRange}, \texttt{npnts}
      is always two.
      For a \texttt{ptset\_type} of \texttt{PointList}, \texttt{npnts} is
      the number of points or cells in the \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_info})
\item [\texttt{pnts}]
      Array of points or cells in the point set.
      (\textcolor{input}{Input} for \texttt{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_hole\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}
