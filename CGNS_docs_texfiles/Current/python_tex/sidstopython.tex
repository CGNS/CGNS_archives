% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{SIDS-to-Python (CGNS/Python)}
\date{}
\release{3.1.2}
\author{The CGNS Steering Committee}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This document is part of the CGNS documentation.
The SIDS-to-Python document describes the CGNS/SIDS mapping with
the Python programming language.

This is version 0.1 of the mapping, approved by the CGNS Steering Committee
on March the 2nd 2011.

More information can be found in \href{http://www.cgns.org}{http://www.cgns.org}


\chapter{CGNS/Python Tree}
\label{sids-to-python::doc}\label{sids-to-python:reference-sids-to-python}\label{sids-to-python:sids-to-python}\label{sids-to-python:cgns-python-tree}
The CGNS/Python mapping defines a \textbf{tree} structure composed of
\textbf{nodes} implemented for the \emph{Python} programming langage.
A special \textbf{links} structure is also defined for a correct mapping of
the management of files on the disk.
The mapping presented here is \emph{NOT} a library \footnote{
The Open Source \emph{pyCGNS} Python module defines services on the top
of this CGNS/Python mapping.
}, it is the lowest possible
correspondance between a CGNS/SIDS structure and a Python
representation.
This specification is public and could be used as the basis for Python
based CGNS application interoperability.
\emph{Python} is an interpreted langage and it has a textual representation of
its objects, this representation can be used for CGNS/Python trees as well.


\section{Commitment with CGNS standard}
\label{sids-to-python:commitment-with-cgns-standard}
The mapping of the SIDS into a CGNS/Python structure uses the node as atomic
structure. Comparing to CGNS/ADF or CGNS/HDF5, the contents
of a node is
unchanged in CGNS/Python. The way we represent data is different but all
nodes attributes found in the section 6 of
the \emph{SIDS-to-ADF File Mapping Manual} \footnote{
The \emph{SIDS-to-ADF} {\hyperref[sids-to-python:cg2]{{[}CG2{]}}} or \emph{SIDS-toHDF5} {\hyperref[sids-to-python:cg3]{{[}CG3{]}}} documents
of \emph{cgns.org} have the
detailled description of each node of the standard.
} are applicable to the
CGNS/Python mapping.

The \textbf{data type} mapping is changed compared to CGNS/ADF or CGNS/HDF5, the
actual representation of basic types such as integers, floats and strings
are closely mapped to the Python data types.
See the table {\hyperref[sids-to-python:table-data-types]{\emph{Data types}}}.

Other elements of the node description are like the CGNS/ADF or CGNS/HDF5
mappings, in particular the \textbf{dimensions} and the order of these dimensions.
The CGNS/SIDS section 3.1 states that the dimensions order should be the
so-called \emph{Fortran indexing convention} which states the column index is
the first. The CGNS/Python nodes should respect this requirements.

\begin{notice}{warning}{Warning:}
The Python arrays can be defined with either a \emph{C} or a \emph{Fortran} \emph{flag},
this \emph{flag} is used to set or to find the order used for the internal
storage of an array. It has \textbf{no effect} on the dimensions of a \emph{numpy}
array, but on its internal memory layout.
It's up to the user to manage this flag and its impact on the use of an
array, in particular for the read/write on the disks through the C API.
\end{notice}

For example, section 6.1.2.2  describes the \code{DimensionalUnits\_t} node
with dimensions values \code{(32,5)}.
This should be understood as \emph{Fortran} order values, and thus \code{(32,5)}
should be found as this in the \emph{shape} of the \emph{numpy} array \footnote{
We show in the textual representation section that this dimension
ordering could lead to quite complicated Python code, but our choice
was to take the implementation from the `Fortran' world,
which is the basis of the CFD world. It would be up to the user to
write his own application layer for a better Python interface.
}
whichever status the \emph{Fortran} flag set has.

A \emph{numpy} array with the \emph{C} flag set should also have a shape of
\code{(32,5)}, again, the internal representation of this \emph{C} array has to
be taken into account during read/write operations.

See the \emph{C API} and \emph{Examples and Tips} sections about this requirement and
its impact on \emph{numpy} array use.


\section{The node structure}
\label{sids-to-python:the-node-structure}
The structure of a CGNS data set is held in a so-called \textbf{CGNS/Python tree}.
The tree is composed of nodes, each node may have children which are nodes
too. The node structure is a python sequence (i.e. list or tuple), composed
of four entries: the name, the value, the list of children and the type.
\begin{quote}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
\emph{Attribute}
} & \textbf{
\emph{type}
}\\
\hline

Name
 & 
string
\\

Value
 & 
\emph{numpy} array
\\

Children
 & 
list of CGNS/Python nodes
\\

Type
 & 
string
\\
\hline
\end{tabulary}

\end{quote}

The CGNS/Python mapping requires that:
\begin{quote}

The \emph{name} is a Python string, it should not be empty. The name should
not have more than 32 chars and should not have \code{/} in it. The names
\code{.} (a single dot) And \code{..} (dot dot) are forbidden (but names with dot
and something else are allowed, for example \code{Zone.001} is ok).

The representation of \emph{values} uses the numpy library array. It makes
it possible to share an already existing memory zone with
the Python object. The numpy mapping of the values is detailled
hereafter. An empty value should be represented as None, any other
value is forbidden.

The \emph{children list} can be a list or a tuple. The use of a list is
strongly recommended but not mandatory. A read-only tree can be
declared as a tuple. It is the responsibility of the applications to
parse sequences wether these are lists or tuples. A node without child
has the empty list \code{{[}{]}} as children list.

The \emph{type} is the Python string representation of the CGNS/SIDS type \footnote{
The CGNS/SIDS type (see {\hyperref[sids-to-python:cg1]{{[}CG1{]}}}) is the type of the node, \emph{NOT} the
type of the data contained into the node.
}
(i.e. it is the same for CGNS/ADF or CGNS/HDF5). A type string cannot be
empty.
\end{quote}

We have now a typical CGNS/Python node, which can be represented with
the pattern \footnote{
The syntax is: \code{\textless{}A:T\textgreater{}} with \code{A} attribute name and \code{T} attribute
type. The types are detailled in another section. The \code{\textless{}A:T\textgreater{}*} means
zero or more \code{\textless{}A:T\textgreater{}} separated by \code{,} if more than one.
}:

\begin{Verbatim}[commandchars=@\[\]]
node = @PYGZlb[] @textless[]name:string@textgreater[], @textless[]value:numpy.array@textgreater[], @PYGZlb[] @textless[]child:node@textgreater[]* @PYGZrb[], @textless[]cgns-type:string@textgreater[] @PYGZrb[]
\end{Verbatim}

We use there the textual representation of a Python object. All the Python
types used in this CGNS/Python mapping have a full textual representation.
This is detailled in the next section.

The order of the values is significant, for example \code{node{[}0{]}} should always
be the name of the node (Python has an index ordering starting with zero)

We see now that a CGNS/Python tree is a node. This node has children
which have children and so on... Any node can be held as a subpart of a
complete tree, we say each node is a \emph{sub-tree}.
Our CGNS/Python tree has a \emph{root} node which is its first node.
There is no clear definition of a \emph{root} node in the CGNS/SIDS or in the
SIDS mappings.

In the case of a \emph{CGNSBase\_t} level node, the CGNS/ADF or CGNS/HDF5
defines a sound node which can be mapped to CGNS/Python. However, the CGNS/SIDS
states that several bases can be found in a CGNS tree. The father node of a
base would have the pattern:

\begin{Verbatim}[commandchars=@\[\]]
root = @PYGZlb[] @textless[]CGNSLibraryVersion:node@textgreater[], @textless[]CGNSBase:node@textgreater[]* @PYGZrb[]
\end{Verbatim}

Which is not consistent with a \emph{normal} node. We want to remove this exception,
we define a CGNS/Python tree root, or first node, as a list with a compliant
CGNS/Python node. which is not the \emph{node} pattern.
Then the applications have to have a specific
way to manage this first node. This lack of \emph{root} node is not that important
when you use the CGNS/MLL because the function are hidding the actual node
implementation. With CGNS/Python, the user can manage the nodes as true
Python objects, and we have to provide him with a sound interface, or at
least as sound as possible. For this consistency reason,
the CGNS/Python mapping defines a new type for the \emph{root} node,
see the {\hyperref[sids-to-python:reference-cgnstree-t]{\emph{CGNSTree\_t type}}} section.


\section{Textual representation}
\label{sids-to-python:textual-representation}
It is possible to declare a CGNS/Python node as a textual
representation. There is a exemple of a zone connectivity sub-tree
with the CGNS/Python in textual mode, a simple \code{PointRange} node with
two 3D indices:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pr}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{PointRange}\PYG{l+s}{'}\PYG{p}{,}
    \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
    \PYG{l+s}{'}\PYG{l+s}{IndexRange\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

The \code{PointRange} node has no child, the children list is an empty
list. The values of the array are initialized with a list, the order
of the elements in the list matches the \emph{Fortran} indexing: in that
example the first point indices are \code{{[}1,1,1{]}} and the second point
indicies are \code{{[}25,9,1{]}}.

The evaluation of this string by the Python interpreter creates a CGNS/Python
compliant node as a Python list. Please note the types of this
\code{pr} node, there are only native Python types (list, string,
integer) and \emph{numpy} types or enumerates. You have to have a variable to
hold the node or the CGNS sub-tree, if you have no reference to the actually
created Python objects these will be unreachable and thus garbaged.

The textual representation can be \emph{import}-ed as any Python textual file,
with all possible Python use you can imagine.

\begin{notice}{warning}{Warning:}
The Python lists are objects. When you refer to a list you do not
copy this list unless you ask for such a copy. This is important because
if you modify an existing list you modify an object that could be used
by others. In the CGNS/Python mapping the children of a node is a list of
nodes. If you refer to such a list without a copy, any modification of this
child list will impact nodes using this list. This is detailled in the
section \emph{Examples and Tips} .
\end{notice}


\section{Numpy array mapping}
\label{sids-to-python:numpy-array-mapping}
A CGNS/Python node value is a \emph{numpy} array, this python object contains
the \textbf{number of dimensions}, the \textbf{dimensions}, the \textbf{data type} and
the actual
\textbf{data} array. Then this implicit information is not a part of the \emph{node}
structure.
As we really want to have the most generic node as possible, we require that
even single dimension values should be stored as \emph{numpy} array. A single
integer, float or a single string should be embedded into a \emph{numpy} array.

As we mentionned before, an empty value has to be represented by \code{None}
which is a native Python value, not a \emph{numpy} value:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gc}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Grid\#002}\PYG{l+s}{'}\PYG{p}{,}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{p}{[}\PYG{n}{cx}\PYG{p}{,}\PYG{n}{cy}\PYG{p}{,}\PYG{n}{cz}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{GridCoordinates\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

Here \code{cx}, \code{cy}, \code{cz}, are nodes, not arrays.

The \emph{numpy} end-user interface makes it possible to define
some of these required data as deduction of required
parameters. The number of dimensions is the size of the so-called
shape. The dimensions can be forced for empty values or can be deduced
from the data itself:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{i}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

The first declaration has dimension 1, number of dims 1, data type
\code{float64}, all deduced from the data declaration, the second has
dimensions \code{(5,3,7)}, number of dimensions 3, data type set as
\code{int32}.

A \emph{numpy} array can be declared as \emph{C order} or \emph{Fortran order}.
There is no requirements in this mapping wether the internal layout of the
memory should be \emph{C} or \emph{Fortran}. However, an array should have a shape
with the same order of dimensions as described in
the \emph{SIDS-to-ADF File Mapping Manual} ({\hyperref[sids-to-python:cg2]{{[}CG2{]}}}).

\begin{notice}{warning}{Warning:}
If you use the Python C API, it is the responsability to the
application to check the \emph{numpy} ordering flag and to manage
the arrays with respect to memory layout. See the \emph{C API} section.
\end{notice}

The way to get the node data information regarding the {\hyperref[sids-to-python:cg2]{{[}CG2{]}}}
datatypes and dimensions requirements is to access to the \emph{numpy} object
attributes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{pr}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{dims}\PYG{o}{=}\PYG{n}{pr}\PYG{o}{.}\PYG{n}{shape}
\PYG{n}{ndims}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{pr}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\PYG{n}{datatype}\PYG{o}{=}\PYG{n}{pr}\PYG{o}{.}\PYG{n}{dtype}
\PYG{n}{fortranorder}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{isfortran}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{)}
\PYG{n}{corder}\PYG{o}{=}\PYG{o+ow}{not} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{isfortran}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{)}
\end{Verbatim}


\section{Data types}
\label{sids-to-python:table-data-types}\label{sids-to-python:data-types}
A value is a numpy array, the contents of an array is homogeneous and has a
data type. The data types of your CGNS/Python arrays depends on the
data type as defined in {\hyperref[sids-to-python:cg2]{{[}CG2{]}}}.

The type of the data can be set at the creation time,
the \emph{numpy} type is associated to the \emph{ADF} type required by the
CGNS/SIDS. A bad data type, even if it silently looks like the result
you want, would lead to an non-compliant CGNS tree.
The required mapping for the end-user interface uses the types :

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
\emph{ADF type}
} & \textbf{
\emph{Numpy type(s)}
} & \textbf{
\emph{Remarks}
}\\
\hline

\emph{I4}
 & 
\emph{`i' int32}
 & 
(1)
\\

\emph{I8}
 & 
\emph{`l' int64}
 & 
(2)
\\

\emph{R4}
 & 
\emph{`f' float32}
 & 
(3)
\\

\emph{R8}
 & 
\emph{`d' float64}
 & 
(4)
\\

\emph{C1}
 & 
\emph{`c' `\textbar{}S1'}
 & 
(5)
\\
\hline
\end{tabulary}


All other \emph{ADF} or \emph{numpy} types are ignored. The string type is a bit special,
see the remark (5) about the strings used in \emph{numpy} arrays.

\textbf{Remarks:}
\begin{enumerate}
\item {} 
The 32bits precision has to be forced, the default
integer size in python the \code{int64} data type.
To create an \emph{I4} array, you can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{i}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item {} 
The 64bits precision is the default integer in python.
To create an \emph{I8} array, you can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item {} 
The 32bits precision has to be forced, the default
float size in python is \code{float64}.
To create an \emph{R4} array, you can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.4}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{f}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item {} 
The 64bits precision is the default float in python.
To create an \emph{R8} array, you can use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.4}\PYG{p}{]}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

\item {} 
The array has to be created as a char multi-dimensionnal
array. An incorrect creation with a simple statement
such as: \code{numpy.array('GoverningEquations')} produces
a \emph{wrong} zero dimension array. The correct creation for
a single value could be:
\code{numpy.array(tuple('GoverningEquations'),'\textbar{}S1')}
where the shape (i.e. the dimensions of the array)
is \code{(18,)}.

\end{enumerate}


\chapter{Specific CGNS/Python topics}
\label{sids-to-python:specific-cgns-python-topics}

\section{The CGNSTree\_t type}
\label{sids-to-python:reference-cgnstree-t}\label{sids-to-python:the-cgnstree-t-type}
The tree structure of a CGNS data set is broken by the exception of the root
node. We take the opportunity of this new CGNS/Python mapping to add a
consistent root node for the CGNS tree \footnote{
This CGNS/Python feature adds \emph{NON-SIDS} type(s) and this should be
added or removed by the user application during the read and the
write to the disk with a CGNS/ADF or CGNS/HDF5 compliance.
}.

The \emph{CGNSTree\_t} type is a node with the pattern:

\begin{Verbatim}[commandchars=@\[\]]
root= @PYGZlb[] @textless[]name:string@textgreater[], None, @PYGZlb[] @textless[]CGNSLibraryVersion:node@textgreater[], @textless[]CGNSBase:node@textgreater[]* @PYGZrb[], 'CGNSTree@_t' @PYGZrb[]
\end{Verbatim}

The children list is the CGNS/ADF-like root node. The \emph{CGNSTree} node has a
user-defined name, no value and a fixed \emph{CGNSTree\_t} type.


\section{Legacy CGNS types alternative}
\label{sids-to-python:legacy-cgns-types-alternative}
The CGNS/SIDS defines all CGNS types and has a rule to suffix them with \code{\_t}.
There are some exceptions where some CGNS/SIDS types have been translated
into strings with a special syntax.

The CGNS/Python mapping allows the use of alternate types for these, the
user can either use the legacy type or the alternate CGNS/Python type.
The alternate types are:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
CGNS/SIDS type
} & \textbf{
CGNS/Python optional type
}\\
\hline

\code{"int{[}1+...+IndexDimension{]}"}
 & 
\code{DiffusionModel\_t}
\\

\code{"int{[}IndexDimension{]}"}
 & 
\code{Transform\_t}
\\

\code{"int{[}IndexDimension{]}"}
 & 
\code{InwardNormalIndex\_t}
\\

\code{"int"}
 & 
\code{EquationDimension\_t}
\\
\hline
\end{tabulary}


Please note the \code{{[}"{]}} character which is part of the CGNS legacy type.

\begin{notice}{warning}{Warning:}
This CGNS/Python feature adds \emph{NON-SIDS} type(s) and this should be
added or removed by the user application during the read and the
write to the disk with a CGNS/ADF or CGNS/HDF5 compliance.
The CGNS.MAP module has an option to check and remove these alternate
types. As long as your application has
interoperability with another CGNS/Python application there should be
no problem.
\end{notice}


\section{Links}
\label{sids-to-python:links}
The \textbf{links} are used to set and get CGNS symbolic links information.
This information is relevant only during read/write operations on disks.
A CGNS/Python tree cannot have embedded links, as this tree is a list of
lists making a link to another list is non-sense in Python \footnote{
A Python list is a reference, if you put a list as a child of another
list the Python interpreter actually refers to the child list. Then
a child can be shared by two different lists if you do not ask for
a copy. In other words, the links are the natural way of referencing
to lists in Python.
}.
The \textbf{links} list is an extra information, not embedded into the CGNS/Python
tree, and only used as disk-related operations.

\begin{notice}{warning}{Warning:}
In the case a CGNS/Python application would not like to follow a
link and then to have some \emph{missing} data in its CGNS tree, the
so-called \emph{linked-from} node has to be removed from its parent
children list.
\end{notice}

This \textbf{links} list is an unsorted list of \emph{link-entries} with only one
entry per link. A \emph{link-entry} is an ordered list of Python string values:
\begin{quote}

The \emph{target directory name} is the linked-to directory name, as it would be
used to open it. It should be a valid absolute/relative file path as a plain
Python string or \code{None}.

The \emph{target file name} is the linked-to file name, as it would be used to
open it. It should be a valid absolute/relative path as a plain Python string.
Its path-prefix part and its file extension part can be empty but the
filename itself cannot.

The \emph{target node name} is the linked-to node name as a plain Python string.
It should be the \textbf{absolute} path of the node in the linked-to file.
This value cannot be empty.

The \emph{local node name} is the \textbf{absolute path} of the node in the source
Python/CGNS tree. This plain Python string cannot be empty.
\end{quote}

The links with a second level file, in other words the links in a file you
are parsing after following a first link, are \textbf{always} referred as if you
where in the \emph{target filename}. Then, a list of links can be reused from one
parse to another, because the \code{links} list is relative to the target file.
The example hereafter can be an \emph{input} as well as an \emph{output} links list,
an application would set it for a \emph{save} or get it from a \emph{load}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[} \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{/tools/CFD/ref\#M6}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{M6\PYGZus{}A.cgns}\PYG{l+s}{'}  \PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{/Base\#1/ReferenceState}\PYG{l+s}{'}\PYG{p}{,}
                                     \PYG{l+s}{'}\PYG{l+s}{/Base/ReferenceState}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,}
  \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{/tmp/restart}\PYG{l+s}{'}     \PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{M6\#001.cgns}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{/Base\#1/Zone1/FlowSolution\#EndOfRun}\PYG{l+s}{'}\PYG{p}{,}
                                     \PYG{l+s}{'}\PYG{l+s}{/Base/Zone1/FlowSolution\#Init}\PYG{l+s}{'}\PYG{p}{]}
\PYG{p}{]}
\end{Verbatim}

The \emph{target directory name} information is distinct to the filename,
because you can have different actual target files depending on the search
paths you set. This information is relevant as ouput from the read of an
actual file, it should be set to \emph{None} or ignored for a write. During a write,
the only information taken into account should be the \emph{target file name},
\emph{target node name}  and the \emph{local node name}.

In the example above, the entries are interpreted in a different way depending
if they are result of a \emph{read} or directives for a \emph{write}. In the case of a
read, the first entry means that the file we have read has a node
\code{/Base/ReferenceState} which is a link to the node \code{/Base\#1/ReferenceState}
in the file \code{M6\_A.cgns}. The first directory of the file search path
in which the file \code{M6\_A.cgns} has been found is \code{/tools/CFD/ref\#M6}.
In the case of a \emph{write}, the same entry means that the application should
create a link for the node \code{/Base/ReferenceState} when it reaches it.
This link would have \code{M6\_A.cgns} as target file and
\code{/Base\#1/ReferenceState} as target node. The \code{/tools/CFD/ref\#M6} value
is ignored.

\begin{notice}{warning}{Warning:}
The links list is relative to the current tree. If you want to track
links of links your application has to manage this by itself, setting or
getting links list during the different tree traversals.
\end{notice}


\section{C API}
\label{sids-to-python:c-api}
There is no requirement on the way you would create or manage a numpy array
at the C API level. But you have to remember that the definition of the
node contents is SIDS-to-ADF which states that data arrays and index ordering
use the \emph{Fortran} convention.

You can manage all your numpy arrays with the C order in memory, but you have
to be sure that the storage on the disk, i.e. using ADF or HDF5, has the
correct fortran orders. The storage also has to be contiguous in the memory.
When you create or obtain a copy of a numpy array you can set a flag to
force a C or Fortran ordering:
one of the \code{NPY\_CCONTIGUOUS} or \code{NPY\_FCONTIGUOUS} flag can be set.
In the case of a \code{NPY\_CCONTIGUOUS} flag set, it is up to the application to
set a Fortran memory layout and a Fortran index ordering while reading/writing
data to/form a CGNS/ADF or CGNS/HDF5 file \footnote{
For example, \emph{CGNS.MAP} detects th \code{NPY\_FCONTIGUOUS} and forces
a data and dimensions transpose during the read/write (unless the
user forces the \emph{CGNS.MAP.S2P\_NOTRANSPOSE} flag in the \code{load} or
the \code{save}).
}.

The \emph{numpy} \emph{C API} allows the share of memory zone. In other words you can
have a \emph{Fortran} or \emph{C} array you can directly set as your \emph{numpy} array
without duplication. You can reduce the memory use when your application
can handle this, you can also set the \code{NPY\_OWNDATA} flag to indicate to
\emph{numpy} that it should not release the array memory when the \emph{numpy}
array object is garbaged.


\chapter{Examples and tips}
\label{sids-to-python:examples-and-tips}
Python comes from the C world, as well as the numpy library. This means
that many behavior are assuming C-order in dimensions. The
CGNS/Python mapping states that arrays should have a Fortran indexing
for their actual data and that the dimension
order of the data is those detailled in the {\hyperref[sids-to-python:cg2]{{[}CG2{]}}} and {\hyperref[sids-to-python:cg3]{{[}CG3{]}}}
documents.

We give here some known issues and tips to handle this Fortran indexing in
CGNS/Python. We use specific CGNS/SIDS structures to illustrate our
examples.


\section{IndexRange\_t}
\label{sids-to-python:indexrange-t}
The \emph{IndexRange\_t} is an integer array of dimensions \emph{(IndexDimensions,2)}
as detailled in \footnotemark[1]. The node data, in the example here, is two points with
three indices. The \emph{Python-ish} way to define them is to have a list of
two lists of integers, which leads to problems if you forget your fortran
order. We want to set a node with the following Python code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{node}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{PointRange}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{IndexRange\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

Now we see how to declare a correct \emph{a} variable as a \emph{numpy} array.
If you do not specify an order to \emph{numpy}, the default is the C-order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{isfortran}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[1,2,3]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(2,3)}
\end{Verbatim}

This \emph{numpy} array is correct but you would have to transpose dimensions
are memory layout before a storage on disk.
Or you can enter the list itself using an explicit Fortran-order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{isfortran}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[1,4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(3,2)}
\end{Verbatim}

In that case, the \emph{shape} is correct but the user has no mean to know wether
your convention is C or Fortran. You can set the fortran flag for this.
The possible creation of the array above is then:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{isfortran}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{[1,4]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(3,2)}
\end{Verbatim}

Then an application can detect your array has \emph{Fortran} order and should
be stored as found without any transpose.


\section{IndexArray\_t}
\label{sids-to-python:indexarray-t}
There is another example switching from one order to another, this is used
to add a point in a list in an easier way

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{node}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{PointList}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{IndexArray\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

The possible creation of the array \code{a} above is then:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{array([[1, 4],}
\PYG{g+go}{       [2, 5],}
\PYG{g+go}{       [3, 6]], dtype=int32)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{array([[1, 2, 3],}
\PYG{g+go}{       [4, 5, 6],}
\PYG{g+go}{       [7, 8, 9]], dtype=int32)}
\end{Verbatim}

You see that the syntax is completely unreadable, we use the \emph{numpy} transpose
attribute \code{T} to switch from \emph{Fortran} to \emph{C} order and back..
If you start with the \emph{C} order, the Python syntax is clear:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{array([[1,2,3],}
\PYG{g+go}{       [4,5,6],  dtype=int32)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}
\PYG{g+go}{array([[1, 2, 3],}
\PYG{g+go}{       [4, 5, 6],}
\PYG{g+go}{       [7, 8, 9]], dtype=int32)}
\end{Verbatim}

And the application in charge of the \emph{write} to the disk that would
detect the abscence of \emph{Fortran} flag and then transpose the array and its
dimension.


\section{DimensionalUnits\_t}
\label{sids-to-python:dimensionalunits-t}
This node contains strings. The strings are an issue in CGNS/Python because
we want to use the raw level for \emph{numpy} (instead of \emph{numpy} module proposed
for string manipulation). We want to keep a common interface for all nodes
and we do not want an exception with strings. The \emph{DimensionalUnits\_t} node
can be defined as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{node}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+sb}{{}`DimensionalUnits{}`}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+sb}{{}`DimensionalUnits\PYGZus{}t{}`}\PYG{p}{]}
\end{Verbatim}

Now we see how we can defined the \emph{numpy} array in variable \emph{a}.
The \emph{DimensionalUnits\_t} states we need a \emph{(32,5)} array of chars.
In the case of a fixed size multi-dimensionnal string array, each entry
should be split as a sequence with a fixed max size (usually 32
chars):

\begin{Verbatim}[commandchars=@\[\]]
a=numpy.array(@PYGZlb[]
                tuple('@%-32s'@%'Kilogram'),
                tuple('@%-32s'@%'Meter'),
                tuple('@%-32s'@%'Second',)
                tuple('@%-32s'@%'Kelvin'),
                tuple('@%-32s'@%'Radian'),
              @PYGZrb[],'@textbar[]S32',order='Fortran').T
\end{Verbatim}

The shape of the resulting array is \code{(32,5)} again note the \code{T}
at the end of the command which produces the transpose.
You can use a \code{S32}, \code{\textbar{}S1} or \code{c} type directive.
An important point in this \emph{string} as an array is the trailing
\emph{spaces} you have to fill the array cell. You have to use a
\code{string.strip} before any string operation unless your Python
application is aware of this \emph{forced} size.


\section{Zone\_t}
\label{sids-to-python:zone-t}
There we have an interesting example with the use of a data of a node.
The \emph{Zone\_t} node has the dimensions of the \emph{zone}. These dimensions are
a data and theses data values should be used as \emph{dimension} attribute
of the children nodes. In other words, the user takes the \emph{Zone\_t}
dimensions and creates a \emph{numpy} array with them:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{zonenode}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Zone001}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{zonedims}\PYG{p}{,}\PYG{n}{zonechildrenlist}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{Zone\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

The \code{zonedims} \emph{numpy} array can b set as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{zonedims}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{,}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Fortran}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

in the case of a 3D structured zone with \code{(ni,nj,nk)=(3,5,7)}.
If you want to create a solution array with these dimensions, you can
to use the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{zonevertexsize}\PYG{o}{=}\PYG{n}{zonedims}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{zonecellsize}\PYG{o}{=}\PYG{n}{zonedims}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{zonevertexboundarysize}\PYG{o}{=}\PYG{n}{zonedims}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{Verbatim}

This numpy syntax allows the user to take the whole column as a
so-called \emph{slice}.


\section{Sub-tree imports}
\label{sids-to-python:sub-tree-imports}
For example, the following snippet \emph{imports} a truncated \emph{ReferenceState}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}

\PYG{n}{refvalues}\PYG{o}{=}\PYG{p}{[}
            \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Mach}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{DataArray\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
            \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Reynolds}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{23300000.0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{DataArray\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
            \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{LengthReference}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{DataArray\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
            \PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Density}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.22524863848}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{DataArray\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\PYG{p}{]}

\PYG{n}{data}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{ReferenceState}\PYG{l+s}{'}\PYG{p}{,}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{n}{refvalues}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{ReferenceState\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\end{Verbatim}

Once \emph{import}-ed, your Python code can insert this node in its
structure (here our previous code snippet is in the file \code{refstate.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{restate}

\PYG{n}{tree}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{CGNSTree}\PYG{l+s}{'}\PYG{p}{,}\PYG{n+nb+bp}{None}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{CGNSTree\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}
\PYG{n}{base}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Fuselage}\PYG{l+s}{'}\PYG{p}{,}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{int32}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{CGNSBase\PYGZus{}t}\PYG{l+s}{'}\PYG{p}{]}

\PYG{n}{tree}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{base}\PYG{p}{)}
\PYG{n}{base}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{restate}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
\end{Verbatim}


\section{Sub-tree share}
\label{sids-to-python:sub-tree-share}
A list is a reference. If you put a list into another one, you do not
perform a copy, you use a reference. Then the modification of the first list
is in the second:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}\PYG{o}{=}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}
\PYG{g+go}{[[1, 2, 3], [4, 5, 6]]}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{9}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}
\PYG{g+go}{[[1, 9, 3], [4, 5, 6]]}
\end{Verbatim}

You always have to take care of the lists, in particular if you use large
CGNS/Python trees you want to share to optimize memory. Another point to
keep in mind is that \emph{numpy} copies do \emph{NOT} propagate \emph{Fortran} flag.


\subsection{Glossary}
\label{sids-to-python:glossary}\begin{description}
\index{cgns.org}\item[{\emph{cgns.org}}] \leavevmode\phantomsection\label{sids-to-python:term-cgns-org}
In this document, \emph{cgns.org} refers to the official CGNS web site and
by extension to its contents. For example, the \emph{cgns.org} documentation
is the official documentation found on this web site.
\emph{CGNS} stands for \emph{CFD General Notation System}.

\index{CGNS/SIDS}\item[{CGNS/SIDS}] \leavevmode\phantomsection\label{sids-to-python:term-cgns-sids}
The specification of the CGNS data model. This \emph{cgns.org} document is
the reference for the specification of a \emph{CGNS} compliant tree at the
\emph{conceptual} level. The implementation is achieved once a \emph{mapping} has
been selected (e.g. CGNS/ADF, CGNS/HDF or CGNS/Python).
\emph{SIDS} stands for \emph{Standard Interface Data Structures}.

\index{CGNS/MLL}\item[{CGNS/MLL}] \leavevmode\phantomsection\label{sids-to-python:term-cgns-mll}
The implementation of the CGNS/ADF and CGNS/HDF specifications. This
librarie and its C and Fortran APIs are available on \emph{cgns.org} web site.
\emph{MLL} stands for \emph{mid-level library' (ADF and HDF5 are the
{}`low-level libraries}).

\index{CGNS/ADF}\item[{CGNS/ADF}] \leavevmode\phantomsection\label{sids-to-python:term-cgns-adf}
The \emph{cgns.org} mapping document describing the implementation of SIDS
on the ADF storage layer. This doesn't include the C or fortran actual
implementation which is available only in the CGNS/MLL librarie.
\emph{ADF} stands for \emph{Advanced Data Format} developed by \emph{Boeing} and \emph{NASA}.

\index{CGNS/HDF}\item[{CGNS/HDF}] \leavevmode\phantomsection\label{sids-to-python:term-cgns-hdf}
The \emph{cgns.org} mapping document describing the implementation of SIDS
on the HDF5 storage layer. This doesn't include the C or fortran actual
implementation which is available only in the CGNS/MLL librarie.
\emph{HDF} stands for \emph{Hierarchical Data Format} developed by the \emph{hdf group}.

\index{Python}\item[{Python}] \leavevmode\phantomsection\label{sids-to-python:term-python}
Python is a programming langage. Its success comes from its easy and
powerful syntax and its capabilities in being extended.

\index{numpy}\item[{numpy}] \leavevmode\phantomsection\label{sids-to-python:term-numpy}
The most used numerical library for the Python programming langage.

\end{description}

\begin{thebibliography}{CG1}
\bibitem[CG1]{CG1}{\phantomsection\label{sids-to-python:cg1} 
CGNS SIDS - Standard Interface Data Structure \href{http://www.grc.nasa.gov/WWW/cgns/sids}{http://www.grc.nasa.gov/WWW/cgns/sids}
}
\bibitem[CG2]{CG2}{\phantomsection\label{sids-to-python:cg2} 
SIDS-to-ADF Mapping Reference Manual \href{http://www.grc.nasa.gov/WWW/cgns/filemap}{http://www.grc.nasa.gov/WWW/cgns/filemap}
}
\bibitem[CG3]{CG3}{\phantomsection\label{sids-to-python:cg3} 
SIDS-to-HDF Mapping Reference Manual \href{http://www.grc.nasa.gov/WWW/cgns/filemap\_hdf}{http://www.grc.nasa.gov/WWW/cgns/filemap\_hdf}
}
\bibitem[PY1]{PY1}{\phantomsection\label{sids-to-python:py1} 
Python Programming langage \href{http://www.python.org}{http://www.python.org}
}
\bibitem[PY2]{PY2}{\phantomsection\label{sids-to-python:py2} 
Numpy \href{http://numpy.scipy.org}{http://numpy.scipy.org}
}
\end{thebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
