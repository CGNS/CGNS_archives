\section{Grid Coordinates, Elements, and Flow Solutions}
\label{s:gridflow}
\thispagestyle{plain}

This section defines structure types for describing the grid
coordinates, element data, and flow solution data pertaining to a zone.
Entities of each of the structure types defined in this section are
contained in the |Zone_t| structure (see \autoref{s:Zone}).

\subsection{Grid Coordinates Structure Definition: \texttt{GridCoordinates\_t}}
\label{s:Grid}

The physical coordinates of the grid vertices are described by the 
|GridCoordinates_t| structure.  This structure contains a list for the 
data arrays of the individual components of the position vector.  It also
provides a mechanism for identifying rind-point data included within the
position-vector arrays.

\begin{alltt}
  GridCoordinates\_t< int IndexDimension, int VertexSize[IndexDimension] > :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)
 
    Rind\_t<IndexDimension> Rind ;                                           (o/d)

    List( DataArray\_t<DataType, IndexDimension, DataSize[]> 
          DataArray1 ... DataArrayN ) ;                                     (o)

    DataClass\_t DataClass ;                                                 (o)
    
    DimensionalUnits\_t DimensionalUnits ;                                   (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the \texttt{Descriptor\_t},
      \texttt{DataArray\_t}, and \texttt{UserDefinedData\_t} lists are
      as shown; users may choose other legitimate names.
      Legitimate names must be unique within a given instance of
      \texttt{GridCoordinates\_t} and shall not include the names
      \texttt{DataClass}, \texttt{DimensionalUnits}, or \texttt{Rind}.
\item There are no required fields for \texttt{GridCoordinates\_t}.
      \texttt{Rind} has a default if absent; the default is equivalent
      to having a \texttt{Rind} structure whose \texttt{RindPlanes}
      array contains all zeros (see \autoref{s:Rind}).
\item The structure parameter \texttt{DataType} must be consistent with
      the data stored in the \texttt{DataArray\_t} substructures (see
      \autoref{s:DataArray}).
\end{notes}

\texttt{GridCoordinates\_t} requires two structure parameters:
\texttt{IndexDimension} identifies the dimensionality of the grid-size
arrays, and \texttt{VertexSize} is the number of vertices in each index
direction excluding rind points.
For unstructured zones, \texttt{IndexDimension} is always 1 and
\texttt{VertexSize} is the total number of vertices, excluding rind
points.

The grid-coordinates data is stored in the list of |DataArray_t| entities;
each |DataArray_t| structure entity may contain a single component of
the position vector (e.g., three separate |DataArray_t| entities are used
for $x$, $y$, and $z$).  
Standardized data-name identifiers for the grid coordinates are described
in \hyperref[s:dataname]{Appendix~\ref*{s:dataname}}.

\texttt{Rind} is an optional field that indicates the number of
rind planes (for structured grids) or rind points or elements (for
unstructured grids) included in the grid-coordinates data.
If \texttt{Rind} is absent, then the \texttt{DataArray\_t} structure
entities contain only ``core'' vertices of a zone; core refers to all
interior and bounding vertices of a zone --- \texttt{VertexSize} is the
number of core vertices.
Core vertices in a zone are assumed to begin at |[1,1,1]|
(for a structured zone in 3-D) and end at \texttt{VertexSize}.
If \texttt{Rind} is present, it will provide information on the number
of ``rind'' points in addition to the core points that are contained in
the \texttt{DataArray\_t} structures.

|DataClass| defines the default class for data contained in the
|DataArray_t| entities.
For dimensional grid coordinates, |DimensionalUnits| may be used to
describe the system of units employed.
If present, these two entities take precedence over the corresponding
entities at higher levels of the CGNS hierarchy.
The rules for determining precedence of entities of this type are
discussed in \autoref{s:precedence}.
An example that uses these grid-coordinate defaults is shown in
\autoref{s:grid_example}.

The \fort{UserDefinedData\_t} data structure allows arbitrary
user-defined data to be stored in \fort{Descriptor\_t} and
\fort{DataArray\_t} children without the restrictions or implicit
meanings imposed on these node types at other node locations.

\enlargethispage{\baselineskip}
%\noindent {\bf FUNCTION} |DataSize[]|:
\subsubsection*{FUNCTION \texttt{DataSize[]}:}

\noindent return value: one-dimensional |int| array of length
                        |IndexDimension| \\
\noindent dependencies: |IndexDimension|, |VertexSize[]|, |Rind|

|GridCoordinates_t| requires a single structure function, named |DataSize|,
to identify the array sizes of the grid-coordinates data.  A function is 
required for the following reasons:
\begin{myitemize}
\item
 the entire grid, including both core and rind points, is stored in 
 the |DataArray_t| entities;
\item
 the |DataArray_t| structure is simple in that it doesn't know anything
 about core versus rind data; it just knows that it contains data 
 of some given size;
\item
 to make all the |DataArray_t| entities syntactically consistent in
 their size (i.e., by syntax entities containing $x$, $y$ and $z$ must
 have the same dimensionality and dimension sizes), the size of the
 array is passed onto the |DataArray_t| structure as a parameter.
\end{myitemize}

\begin{alltt}
  if (Rind is absent) then
    \{
    DataSize[] = VertexSize[] ;
    \}
  else if (Rind is present) then
    \{ 
    DataSize[] = VertexSize[] + [a + b,...] ;
    \}
\end{alltt}
where |RindPlanes = [a,b,...]| (see \autoref{s:Rind} 
for the definition of |RindPlanes|). 

\subsection{Grid Coordinates Examples}
\label{s:grid_example}

\enlargethispage{\baselineskip}
This section contains examples of grid coordinates.  These examples
show the storage of the grid-coordinate data arrays, as well as different
mechanisms for describing the class of data and the system of units or
normalization.

\begin{example}{Cartesian Coordinates for a 2-D Structured Grid}
\label{ex:grid1}

Cartesian coordinates for a 2-D grid of size $17\times33$; the data
arrays include only core vertices, and the coordinates are in units of feet.
\begin{alltt}
  !  IndexDimension = 2
  !  VertexSize = [17,33]
  GridCoordinates\_t<2, [17,33]> GridCoordinates =
    \{\{
    DataArray\_t<real, 2, [17,33]> CoordinateX =
      \{\{
      Data(real, 2, [17,33]) = ((x(i,j), i=1,17), j=1,33) ;

      DataClass\_t DataClass = Dimensional ;
      
      DimensionalUnits\_t DimensionalUnits = 
        \{\{ 
        MassUnits        = MassUnitsNull ;
        LengthUnits      = Foot ;
        TimeUnits        = TimeUnitsNull ;
        TemperatureUnits = TemperatureUnitsNull ;
        AngleUnits       = AngleUnitsNull ;
        \}\} ;
      \}\} ;

    DataArray\_t<real, 2, [17,33]> CoordinateY =
      \{\{
      Data(real, 2, [17,33]) = ((y(i,j), i=1,17), j=1,33) ;

      DataClass\_t DataClass = Dimensional ;
      
      DimensionalUnits\_t DimensionalUnits = 
        \{\{ 
        MassUnits        = MassUnitsNull ;
        LengthUnits      = Foot ;
        TimeUnits        = TimeUnitsNull ;
        TemperatureUnits = TemperatureUnitsNull ;
        AngleUnits       = AngleUnitsNull ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
From \hyperref[s:dataname]{Appendix~\ref*{s:dataname}}, the identifiers
for $x$ and $y$ are |CoordinateX| and |CoordinateY|, respectively, and
both have a data type of |real|.
The value of |DataClass| in |CoordinateX| and |CoordinateY| indicate
the data is dimensional, and |DimensionalUnits| specifies the appropriate
units are feet.
The |DimensionalExponents| entity is absent from both |CoordinateX| and
|CoordinateY|; the information that $x$ and $y$ are lengths can be
inferred from the data-name identifier conventions in
\autoref{s:dataname_grid}.

Note that FORTRAN multidimensional array indexing is used to store
the data; this is reflected in the FORTRAN-like implied do-loops for
|x(i,j)| and |y(i,j)|.

Since the dimensional units for both $x$ and $y$ are the same, an
alternate approach is to set the data class and system of units using
|DataClass| and |DimensionalUnits| at the |GridCoordinates_t| level, and
eliminate this information from each instance of |DataArray_t|.
\begin{alltt}
  GridCoordinates\_t<2, [17,33]> GridCoordinates =
    \{\{
    DataClass\_t DataClass = Dimensional ;
    
    DimensionalUnits\_t DimensionalUnits = 
      \{\{ 
      MassUnits        = MassUnitsNull ;
      LengthUnits      = Foot ;
      TimeUnits        = TimeUnitsNull ;
      TemperatureUnits = TemperatureUnitsNull ;
      AngleUnits       = AngleUnitsNull ;
      \}\} ;

    DataArray\_t<real, 2, [17,33]> CoordinateX =
      \{\{
      Data(real, 2, [17,33]) = ((x(i,j), i=1,17), j=1,33) ;
      \}\} ;

    DataArray\_t<real, 2, [17,33]> CoordinateY =
      \{\{
      Data(real, 2, [17,33]) = ((y(i,j), i=1,17), j=1,33) ;
      \}\} ;
    \}\} ;
\end{alltt}
Since the \fort{DataClass} and \fort{DimensionalUnits} entities are not
present in \fort{CoordinateX} and \fort{CoordinateY}, the rules
established in \autoref{s:data_dim} dictate that \fort{DataClass}
and \fort{DimensionalUnits} specified at the \fort{GridCoordinates\_t}
level be used to retrieve the information.
\end{example}

\newpage
\begin{example}{Cylindrical Coordinates for a 3-D Structured Grid}
\label{ex:grid2}

Cylindrical coordinates for a 3-D grid whose core size is
$17\times33\times9$.
The grid contains a single plane of rind on the minimum and maximum $k$
faces.
The coordinates are nondimensional.
\begin{alltt}
  !  IndexDimension = 3
  !  VertexSize = [17,33,9]
  GridCoordinates\_t<3, [17,33,9]> GridCoordinates =
    \{\{
    Rind\_t<3> Rind =
      \{\{
      int[6] RindPlanes = [0,0,0,0,1,1] ;
      \}\} ;

    ! DataType = real
    ! IndexDimension = 3
    ! DataSize = VertexSize + [0,0,2] = [17,33,11]
    DataArray\_t<real, 3, [17,33,11]> CoordinateRadius =
      \{\{
      Data(real, 3, [17,33,11]) = (((r(i,j,k), i=1,17), j=1,33), k=0,10) ;

      DataClass\_t DataClass = NormalizedByUnknownDimensional ;
      \}\} ;

    DataArray\_t<real, 3, [17,33,11]> CoordinateZ     = \{\{ \}\} ;
    DataArray\_t<real, 3, [17,33,11]> CoordinateTheta = \{\{ \}\} ;
    \}\} ;
\end{alltt}
The value of |RindPlanes| specifies two rind planes on the minimum and
maximum $k$ faces.
These rind planes are reflected in the structure function |DataSize|
which is equal to the number of core vertices plus two in the  $k$ dimension.
The value of |DataSize| is passed to the |DataArray_t| entities.
The value of |DataClass| indicates the data is nondimensional.
Note that if \fort{DataClass} is set as \fort{NormalizedByUnknownDimensional}
at a  higher level (\fort{CGNSBase\_t} or \fort{Zone\_t}), then it is not
needed here.

Note that the entities |CoordinateZ| and |CoordinateTheta| are abbreviated.
\end{example}

\begin{example}{Cartesian Coordinates for a 3-D Unstructured Grid}
\label{ex:grid3}

Cartesian grid coordinates for a 3-D unstructured zone where
\fort{VertexSize} is 15.
\begin{alltt}
  GridCoordinates\_t<1, 15> GridCoordinates =
    \{\{

    ! DataType = real
    ! IndexDimension = 1
    ! DataSize = VertexSize = 15
    DataArray\_t<real, 1, 15> CoordinateX =
      \{\{
      Data(real, 1, 15) = (x(i), i=1,15) ;
      \}\} ;

    DataArray\_t<real, 1, 15> CoordinateY =
      \{\{
      Data(real, 1, 15) = (y(i), i=1,15) ;
      \}\} ;

    DataArray\_t<real, 1, 15> CoordinateZ =
      \{\{
      Data(real, 1, 15) = (z(i), i=1,15) ;
      \}\} ;
    \}\} ;
\end{alltt}
\end{example}

\subsection{Elements Structure Definition: \texttt{Elements\_t}}
\label{s:Elements}

The \fort{Elements\_t} data structure is required for unstructured
zones, and contains the element connectivity data, the element type,
the element range, the parent elements data, and the number of boundary
elements.

\begin{alltt}
  Elements\_t :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)
 
    Rind\_t<IndexDimension> Rind ;                                           (o/d)

    IndexRange\_t ElementRange ;                                             (r)

    int ElementSizeBoundary ;                                               (o/d)

    ElementType\_t ElementType ;                                             (r)

    DataArray\_t<int, 1, ElementDataSize> ElementConnectivity ;              (r)

    DataArray\_t<int, 2, [ElementSize, 2]> ParentElements ;                  (o)
    DataArray\_t<int, 2, [ElementSize, 2]> ParentElementsPosition ;          (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the \texttt{Descriptor\_t} and
      \texttt{UserDefinedData\_t} lists are as shown; users may choose
      other legitimate names.
      Legitimate names must be unique within a given instance
      of \texttt{Elements\_t} and shall not include the names
      \texttt{ElementConnectivity}, \texttt{ElementRange},
      \texttt{ParentElements}, \texttt{ParentElementsPosition}, or \texttt{Rind}.
\item \texttt{IndexRange\_t}, \texttt{ElementType\_t}, and
      \texttt{ElementConnectivity\_t} are the required fields within the
      \texttt{Elements\_t} structure.
      \texttt{Rind} has a default if absent; the default is equivalent
      to having a \texttt{Rind} structure whose \texttt{RindPlanes}
      array contains all zeros (see \autoref{s:Rind}).
\end{notes}

\texttt{Rind} is an optional field that indicates the number of rind
elements included in the elements data.
If \texttt{Rind} is absent, then the \texttt{DataArray\_t} structure
entities contain only core elements of a zone.
If \texttt{Rind} is present, it will provide information on the number
of rind elements, in addition to the core elements, that are contained
in the \texttt{DataArray\_t} structures.

Note that the usage of rind data with respect to the size of the
\texttt{DataArray\_t} structures is different under \texttt{Elements\_t}
than elsewhere.
For example, when rind coordinate data is stored under
\texttt{GridCoordinates\_t}, the parameter \texttt{VertexSize} accounts
for the core data only.
The size of the \texttt{DataArray\_t} structures containing the grid
coordinates is determined by the \texttt{DataSize} function, which adds
the number of rind planes or points to \texttt{VertexSize}.
But for the element connectivity, the size of the \texttt{DataArray\_t}
structures containing the connectivity data is just
\texttt{ElementDataSize}, which depends on \texttt{ElementSize}, and
includes both the core and rind elements.

\fort{ElementRange} contains the index of the first and last elements defined
in \fort{ElementConnectivity}.
The elements are indexed with a global numbering system, starting at 1,
for all element sections under a given \fort{Zone\_t} data structure.
The global numbering insures that each element, whether it's a cell,
a face, or an edge, is uniquely identified by its number.
They are also listed as a continuous list of element numbers within
any single element section.
Therefore the number of elements in a section is:
\begin{alltt}
  ElementSize = ElementRange.end - ElementRange.start + 1
\end{alltt}

The element indices are used for the boundary condition and zone
connectivity definition.

\fort{ElementSizeBoundary} indicates if the elements are sorted, and
how many boundary elements are recorded.
By default, \fort{ElementSizeBoundary} is set to zero, indicating that
the elements are not sorted.
If the elements are sorted, \fort{ElementSizeBoundary} is set to the
number of elements at the boundary.
Consequently:
\begin{alltt}
  ElementSizeInterior = ElementSize - ElementSizeBoundary
\end{alltt}

\fort{ElementType\_t} is an enumeration of the supported element types:
\begin{alltt}
  ElementType\_t := Enumeration(
     ElementTypeNull, ElementTypeUserDefined, NODE, BAR\_2, BAR\_3,
     TRI\_3, TRI\_6, QUAD\_4, QUAD\_8, QUAD\_9,
     TETRA\_4, TETRA\_10, PYRA\_5, PYRA\_14,
     PENTA\_6, PENTA\_15, PENTA\_18, HEXA\_8, HEXA\_20, HEXA\_27,
     MIXED, PYRA\_13, NGON\_n, NFACE\_n );
\end{alltt}
\autoref{s:unstructgrid} illustrates the convention for element numbering.

For all element types except \fort{MIXED}, \texttt{NGON\_n},
and \texttt{NFACE\_n}, \fort{ElementConnectivity}
contains the list of nodes for each element.
If the elements are sorted, then it must first list the connectivity of
the boundary elements, then that of the interior elements.
\begin{alltt}
  ElementConnectivity = Node1\tsub{1}, Node2\tsub{1}, ... NodeN\tsub{1},
                        Node1\tsub{2}, Node2\tsub{2}, ... NodeN\tsub{2},
                        ...
                        Node1\tsub{M}, Node2\tsub{M}, ... NodeN\tsub{M}
\end{alltt}
where \texttt{M} is the total number of elements (i.e.,
\texttt{ElementSize}), and \texttt{N} is the number of nodes per
element.

\fort{ElementDataSize} indicates the total size (number of integers) of
\fort{the array ElementConnectivity}.
For all element types except \fort{MIXED}, \texttt{NGON\_n},
and \texttt{NFACE\_n}, the \fort{ElementDataSize}
is given by:
\begin{alltt}
  ElementDataSize = ElementSize * NPE[ElementType]
\end{alltt}
where \fort{NPE[ElementType]} is a function returning the number of
nodes for the given \fort{ElementType}.
For example, \fort{NPE[HEXA\_8]=8}.

When the section \fort{ElementType} is \fort{MIXED}, the data array
\fort{ElementConnectivity} contains one extra integer per element,
to hold each individual element type:
\begin{alltt}
  ElementConnectivity = Etype\tsub{1}, Node1\tsub{1}, Node2\tsub{1}, ... NodeN\tsub{1},
                        Etype\tsub{2}, Node1\tsub{2}, Node2\tsub{2}, ... NodeN\tsub{2},
                        ...
                        Etype\tsub{M}, Node1\tsub{M}, Node2\tsub{M}, ... NodeN\tsub{M}
\end{alltt}
where again \texttt{M} is the total number of elements, and
\texttt{N}\tsub{\textit{i}} is the number of nodes in element $i$.
In the case of \fort{MIXED} element section, \fort{ElementDataSize} is
given by:
\begin{alltt}
  ElementDataSize = \(\displaystyle\sum\sb{n=\mbox{\scriptsize\ital{start}}}\sp{\mbox{\scriptsize\ital{end}}} (\mbox{NPE[ElementType}\sb{n}\mbox{] + 1})\)
\end{alltt}

Arbitrary polyhedral elements may be defined using the \texttt{NGON\_n}
and \texttt{NFACE\_n} element types.
The \texttt{NGON\_n} element type is used to specify all the faces
in the grid, and the \texttt{NFACE\_n} element type is then
used to define the polyhedral elements as a collection of these faces.
Except for boundary faces, each face of a polyhedral element must be
shared by another polyhedral element.

I.e., for \texttt{NGON\_n}, the data array \texttt{ElementConnectivity}
contains a list of nodes making up each face
in the grid, with the first value for each face defining the number of
nodes making up that face:
\begin{alltt}
  ElementConnectivity = Nnodes\tsub{1}, Node1\tsub{1}, Node2\tsub{1}, ... NodeN\tsub{1},
                        Nnodes\tsub{2}, Node1\tsub{2}, Node2\tsub{2}, ... NodeN\tsub{2},
                        ...
                        Nnodes\tsub{M}, Node1\tsub{M}, Node2\tsub{M}, ... NodeN\tsub{M}
\end{alltt}
where here \texttt{M} is the total number of faces, and
\texttt{N}\tsub{\textit{i}} is the number of nodes in face $i$.
The \texttt{ElementDataSize} is the total number of nodes defining all
the faces, plus one value per face specifying the number of nodes making
up that face.

Then for \texttt{NFACE\_n}, \texttt{ElementConnectivity} contains the
list of face elements making up each polyhedral element, with the first
value for each polyhedra defining the number of faces making up that
polyhedral element.
\begin{alltt}
  ElementConnectivity = Nfaces\tsub{1}, Face1\tsub{1}, Face2\tsub{1}, ... FaceN\tsub{1},
                        Nfaces\tsub{2}, Face1\tsub{2}, Face2\tsub{2}, ... FaceN\tsub{2},
                        ...
                        Nfaces\tsub{M}, Face1\tsub{M}, Face2\tsub{M}, ... FaceN\tsub{M}
\end{alltt}
where now \texttt{M} is the total number of polyhedral elements, and
\texttt{N}\tsub{\textit{i}} is the number of faces in element $i$.
The sign of the face number determines its orientation (i.e., the
direction of the face normal, constructed as defined by the
convention for 2-D elements in \autoref{s:unstructgrid_2d}).
If the face number is positive, the face normal is directed outward; if
it's negative, the face normal is directed inward.
The \texttt{ElementDataSize} is the 
sum of the number of faces defining each
polyhedral element, plus one value per polyhedral element
specifying the number of faces making up that element.

For face elements in 3--D, or bar element in 2--D, additonal data may be provided
for each element in \fort{ParentElements} and \fort{ParentElementsPosition}. The
element numbers of the two adjacent cells for each face are given in
\fort{ParentElements}.  The corresponding canonical positions of the face in the
two parent cells is given in \fort{ParentElementsPosition}; these canonical
face positions are defined in \autoref{s:unstructgrid}.  For faces on the
boundary of the domain, the second parent is set to zero.

The \fort{UserDefinedData\_t} data structure allows arbitrary
user-defined data to be stored in \fort{Descriptor\_t} and
\fort{DataArray\_t} children without the restrictions or implicit
meanings imposed on these node types at other node locations.

\subsection{Elements Examples}
\label{s:element_example}

This section contains four examples of elements definition in CGNS.
The first example is for a simple three-element tetrahedral grid, using
the \texttt{TETRA\_4} element type.
The second example is for the same grid as the first example, but the
elements are treated as general polyhedra to illustrate the use of the
\texttt{NGON\_n} and \texttt{NFACE\_n} element types.
The third and fourth examples are for an unstructured zone with
15 tetrahedral and 10 hexahedral elements, with the third example
defining the elements in separate sections for the \texttt{TETRA\_4} and
\texttt{HEXA\_8} element types, and the fourth example combining them
using the \texttt{MIXED} element type.

\begin{example}{\texttt{TETRA\_4} Element Types}
\label{ex:elements1}

This example uses the simple three-element tetrahedral grid shown in
\autoref{f:ex_tetra}.

\begin{figure}[ht]
   \begin{center}
   \setlength{\unitlength}{1.0in}
   \begin{picture}(2.0,2.25)(0.75,0)
      \drawline(0.0,0.75)(1.125,0.0)(1.0,1.75)(0.0,0.75)
      \drawline(1.125,0.0)(3.125,0.175)(3.125,1.50)(1.125,0.0)
      \drawline(1.00,1.75)(3.125,1.50)
      \dashline{0.05}(0.0,0.75)(2.0,0.875)
      \dashline{0.05}(1.125,0.0)(2.0,0.875)
      \dashline{0.05}(2.0,0.875)(1.0,1.75)
      \dashline{0.05}(2.0,0.875)(3.125,0.175)
      \dashline{0.05}(2.0,0.875)(3.125,1.50)

      \put( 0.00,  0.75 ){\circle*{0.1}}
      \put(-0.10,  0.75 ){\makebox(0,0)[r]{1}}
      \put( 1.125, 0.00 ){\circle*{0.1}}
      \put( 1.175,-0.05 ){\makebox(0,0)[lt]{2}}
      \put( 2.00,  0.875){\circle*{0.1}}
      \put( 2.00,  0.975){\makebox(0,0)[b]{3}}
      \put( 1.00,  1.75 ){\circle*{0.1}}
      \put( 1.05,  1.80 ){\makebox(0,0)[lb]{4}}
      \put( 3.125, 0.175){\circle*{0.1}}
      \put( 3.225, 0.175){\makebox(0,0)[l]{5}}
      \put( 3.125, 1.50 ){\circle*{0.1}}
      \put( 3.225, 1.50 ){\makebox(0,0)[lb]{6}}

      \put( 0.00, 1.30 ){\vector(3,-1){1}}
      \put(-0.05, 1.30 ){\makebox(0,0)[rb]{(1)}}
      \put( 3.60, 1.10 ){\vector(-3,-1){1}}
      \put( 3.65, 1.10 ){\makebox(0,0)[lb]{(2)}}
      \put( 2.30, 2.00 ){\vector(-1,-3){0.25}}
      \put( 2.30, 2.05 ){\makebox(0,0)[lb]{(3)}}
   \end{picture}
   \end{center}
   \caption{Example Tetrahedral Grid}
   \label{f:ex_tetra}
\end{figure}

The element type is \texttt{TETRA\_4}, and the connectivity is defined
in \texttt{ElementConnectivity} by specifying the four nodes comprising
each element, with the order consistent with the
numbering conventions for tetrahedral
elements.
The data in \texttt{ElementConnectivity} is grouped by element; note
that the parentheses are added here for presentation purposes only.
\begin{alltt}
  Zone\_t UnstructuredZone =
    \{\{
    Elements\_t TetraElements =
      \{\{
      IndexRange\_t ElementRange = [1,3] ;

      ElementType\_t ElementType = TETRA\_4 ;

      DataArray\_t<int, 1, NPE[TETRA\_4]\(\times\)3> ElementConnectivity =
        \{\{
        Data(int, 1, NPE[TETRA\_4]\(\times\)3) =
          (1, 2, 3, 4), (2, 5, 3, 6), (2, 6, 3, 4) ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
\end{example}

\begin{example}{\texttt{NGON\_n} and \texttt{NFACE\_n} Element Types}
\label{ex:elements2}

This example uses the same grid as in the previous example, but
treats the elements as general polyhedra to illustrate the use of the
\texttt{NGON\_n} and \texttt{NFACE\_n} element types.
The grid consists of three volume elements, each made up of four face
elements, with each face defined by three nodes.

For each face, the nodes comprising that face are listed in
\texttt{ElementConnectivity} for the \texttt{NGON\_n} element type.
The \texttt{ElementRange} is \texttt{[1,10]}, corresponding to the 10
total faces.
The \texttt{ElementDataSize} is 40, corresponding to the total of 30
nodes defining the 10 faces, plus one value per face specifying the
number of nodes making up that face.

The faces making up the three volume elements are then listed in
\texttt{ElementConnectivity} for the \texttt{NFACE\_n} element type.
The \texttt{ElementRange} is \texttt{[11,13]}, corresponding to the three
volume elements.
The \texttt{ElementDataSize} is 15, corresponding to three volume
elements with four faces per element, plus one value per volume element
specifying the number of faces making up that element.
Note that the face numbers for faces 3 and 8 are negative in the
definition of volume element 3, since their normals point inward for
that element.
Again, the parentheses in \texttt{ElementConnectivity} are for
presentation purposes only.
\begin{alltt}
  Zone\_t UnstructuredZone =
    \{\{
    Elements\_t NgonElements =
      \{\{
      IndexRange\_t ElementRange = [1,10] ;

      ElementType\_t ElementType = NGON\_n ;

      DataArray\_t<int, 1, 40> ElementConnectivity =
        \{\{
        Data(int, 1, 40) =
          (3, 1, 3, 2), (3, 1, 2, 4), (3, 2, 3, 4), (3, 3, 1, 4),
          (3, 2, 3, 5), (3, 2, 5, 6), (3, 5, 3, 6), (3, 3, 2, 6),
          (3, 2, 6, 4), (3, 6, 3, 4) ;
        \}\} ;
      \}\} ;
    Elements\_t NfaceElements =
      \{\{
      IndexRange\_t ElementRange = [11,13] ;

      ElementType\_t ElementType = NFACE\_n ;

      DataArray\_t<int, 1, 15> ElementConnectivity =
        \{\{
        Data(int, 1, 15) =
          (4,  1,  2,  3,  4),
          (4,  5,  6,  7,  8),
          (4, -8,  9, 10, -3) ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
\end{example}

\begin{example}{Separate Element Types}
\label{ex:elements3}

In this example, elements are defined for an unstructured zone with 15
tetrahedral and 10 hexahedral elements.
The elements are written in two separate sections, one for the
tetrahedral elements and one for the hexahedral elements.
\begin{alltt}
  Zone\_t UnstructuredZone =
    \{\{
    Elements\_t TetraElements =
      \{\{
      IndexRange\_t ElementRange = [1,15] ;

      int ElementSizeBoundary = 10 ;

      ElementType\_t ElementType = TETRA\_4 ;

      DataArray\_t<int, 1, NPE[TETRA\_4]\(\times\)15> ElementConnectivity =
        \{\{
        Data(int, 1, NPE[TETRA\_4]\(\times\)15) = (node(i,j), i=1,NPE[TETRA\_4], j=1,15) ;
        \}\} ;
      \}\} ;
    Elements\_t HexaElements =
      \{\{
      IndexRange\_t ElementRange = [16,25] ;

      int ElementSizeBoundary = 0 ;

      ElementType\_t ElementType = HEXA\_8 ;

      DataArray\_t<int, 1, NPE[HEXA\_8]\(\times\)10> ElementConnectivity =
        \{\{
        Data(int, 1, NPE[HEXA\_8]\(\times\)10) = (node(i,j), i=1,NPE[HEXA\_8], j=1,10) ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
\end{example}

\begin{example}{\texttt{MIXED} Element Type}
\label{ex:elements4}

In this example, the same unstructured zone described in 
\hyperref[ex:elements3]{Example~\ref*{ex:elements3}} is written in a
single element section of type \fort{MIXED} (i.e., an unstructured grid
composed of mixed elements).
\begin{alltt}
  Zone\_t UnstructuredZone =
    \{\{
    Elements\_t MixedElementsSection =
      \{\{
      IndexRange\_t ElementRange = [1,25] ;

      ElementType\_t ElementType = MIXED ;

      DataArray\_t<int, 1, ElementDataSize> ElementConnectivity =
        \{\{
        Data(int, 1, ElementDataSize) = (etype(j),(node(i,j),
             i=1,NPE[etype(j)]), j=1,25) ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
\end{example}

\subsection{Axisymmetry Structure Definition: \texttt{Axisymmetry\_t}}
\label{s:Axisymmetry}

The \fort{Axisymmetry\_t} data structure allows recording the axis of
rotation and the angle of rotation around this axis for a two-dimensional
dataset that represents an axisymmetric database.

\begin{alltt}
  Axisymmetry\_t :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)

    DataArray\_t<real,1,2> AxisymmetryReferencePoint ;                       (r)
    DataArray\_t<real,1,2> AxisymmetryAxisVector ;                           (r)
    DataArray\_t<real,1,1> AxisymmetryAngle ;                                (o)
    DataArray\_t<char,2,[32,2]> CoordinateNames ;                            (o)

    DataClass\_t DataClass ;                                                 (o)

    DimensionalUnits\_t DimensionalUnits ;                                   (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the \fort{Descriptor\_t} and
      \fort{UserDefinedData\_t} lists are as shown; users may choose
      other legitimate names.
      Legitimate names must be unique within a given instance
      of \fort{Axisymmetry\_t} and shall not include the names
      \fort{AxisymmetryAngle}, \fort{AxisymmetryAxisVector},
      \fort{AxisymmetryReferencePoint}, \fort{CoordinateNames},
      \fort{DataClass}, or \fort{DimensionalUnits}.
\item \fort{AxisymmetryReferencePoint} and \fort{AxisymmetryAxisVector}
      are the required fields within the \fort{Axisymmetry\_t} structure.
\end{notes}

\fort{AxisymmetryReferencePoint} specifies the origin used for
defining the axis of rotation.

\fort{AxisymmetryAxisVector} contains the direction cosines of the
axis of rotation, through the \fort{AxisymmetryReferencePoint}.
For example, for a 2-D dataset defined in the $(x,y)$ plane,
if \fort{AxisymmetryReferencePoint} contains $(0,0)$ and
\fort{AxisymmetryAxisVector} contains $(1,0)$, the $x$-axis is the
axis of rotation.

\fort{AxisymmetryAngle} allows specification of the circumferential
extent about the axis of rotation.
If this angle is undefined, it is assumed to be 360\degree.

\fort{CoordinateNames} may be used to specify the first and second
coordinates used in the definition of \fort{AxisymmetryReferencePoint}
and \fort{AxisymmetryAxisVector}.
If not found, it is assumed that the first coordinate is
\fort{CoordinateX} and the second is \fort{CoordinateY}.
The coordinates given under \fort{CoordinateNames}, or implied by
using the default, must correspond to those found under
\fort{GridCoordinates\_t}.

\fort{DataClass} defines the default class for numerical data contained
in the \fort{DataArray\_t} entities.
For dimensional data, \fort{DimensionalUnits} may be used to describe
the system of units employed.
If present, these two entities take precedence over the corresponding
entities at higher levels of the CGNS hierarchy, following the standard
precedence rules.

The \fort{UserDefinedData\_t} data structure allows arbitrary
user-defined data to be stored in \fort{Descriptor\_t} and
\fort{DataArray\_t} children without the restrictions or implicit
meanings imposed on these node types at other node locations.

\subsection{Rotating Coordinates Structure Definition: \texttt{RotatingCoordinates\_t}}
\label{s:RotatingCoordinates}

The \fort{RotatingCoordinates\_t} data structure is used to record
the rotation center and rotation rate vector of a rotating coordinate
system.

\begin{alltt}
  RotatingCoordinates\_t :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)

    DataArray\_t<real,1,PhysicalDimension> RotationCenter ;                  (r)
    DataArray\_t<real,1,PhysicalDimension> RotationRateVector ;              (r)

    DataClass\_t DataClass ;                                                 (o)

    DimensionalUnits\_t DimensionalUnits ;                                   (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the \fort{Descriptor\_t} and
      \fort{UserDefinedData\_t} lists are as shown; users may choose
      other legitimate names.
      Legitimate names must be unique within a given instance
      of \fort{RotatingCoordinates\_t} and shall not include the names
      \fort{DataClass}, \fort{DimensionalUnits}, \fort{RotationCenter},
      or \fort{RotationRateVector}.
\item \fort{RotationCenter} and \fort{RotationRateVector}
      are the required fields within the \fort{RotatingCoordinates\_t}
      structure.
\end{notes}

\texttt{RotationCenter} specifies the coordinates of the center of
rotation, and \texttt{RotationRateVector} specifies the components of
the angular velocity of the grid about the center of rotation.
Together, they define the angular velocity vector.
The direction of the angular velocity vector specifies the axis of
rotation, and its magnitude specifies the rate of rotation.

For example, for the common situation of rotation about the $x$-axis,
\texttt{RotationCenter} would be specified as any point on the $x$-axis,
like $(0,0,0)$.
\texttt{RotationRateVector} would then be specified as ($\omega$,0,0),
where $\omega$ is the rotation rate.
Using the right-hand rule, $\omega$ would be positive for clockwise
rotation (looking in the $+x$ direction), and negative for
counter-clockwise rotation.

Note that for a rotating coordinate system, the axis of rotation is
defined in the inertial frame of reference, while the grid coordinates
stored using the \fort{GridCoordinates\_t} data structure are
relative to the rotating frame of reference.

\fort{DataClass} defines the default class for data contained in the
\fort{DataArray\_t} entities.
For dimensional data, \fort{DimensionalUnits} may be used to describe
the system of units employed.
If present, these two entities take precedence over the corresponding
entities at higher levels of the CGNS hierarchy, following the standard
precedence rules.

The \fort{UserDefinedData\_t} data structure allows arbitrary
user-defined data to be stored in \fort{Descriptor\_t} and
\fort{DataArray\_t} children without the restrictions or implicit
meanings imposed on these node types at other node locations.

If rotating coordinates are used, it is useful to store variables
relative to the rotating frame.
Standardized data-name identifiers should be used for these variables,
as defined for flow-solution quantities in
\hyperref[s:dataname]{Appendix~\ref*{s:dataname}}.

\subsection{Flow Solution Structure Definition: \texttt{FlowSolution\_t}} 
\label{s:FlowSolution}

The flow solution within a given zone is described by the |FlowSolution_t|
structure.  This structure contains a list for the data arrays of the
individual flow-solution variables, as well as identifying the grid location
of the solution.  It also provides a mechanism for identifying rind-point
data included within the data arrays.

\begin{alltt}
  FlowSolution\_t< int CellDimension, int IndexDimension, 
                  int VertexSize[IndexDimension], 
                  int CellSize[IndexDimension] > :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)

    GridLocation\_t GridLocation ;                                           (o/d)

    Rind\_t<IndexDimension> Rind ;                                           (o/d)

    IndexRange\_t<IndexDimension> PointRange ;                               (o)
    IndexArray\_t<IndexDimension, ListLength[], int> PointList ;             (o)

    List( DataArray\_t<DataType, IndexDimension, DataSize[]> 
          DataArray1 ... DataArrayN ) ;                                     (o)

    DataClass\_t DataClass ;                                                 (o)
    
    DimensionalUnits\_t DimensionalUnits ;                                   (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the \texttt{Descriptor\_t},
      \texttt{DataArray\_t}, and \texttt{UserDefinedData\_t} lists are
      as shown; users may choose other legitimate names.
      Legitimate names must be unique within a given instance
      of \texttt{FlowSolution\_t} and shall not include the
      names \texttt{DataClass}, \texttt{DimensionalUnits},
      \texttt{GridLocation}, \texttt{PointList}, \texttt{PointRange},
      or \texttt{Rind}.
\item There are no required fields for \texttt{FlowSolution\_t}.
      \texttt{GridLocation} has a default of \texttt{Vertex} if
      absent. \texttt{Rind} also has a default if absent; the
      default is equivalent to having an instance of \texttt{Rind}
      whose \texttt{RindPlanes} array contains all zeros (see
      \autoref{s:Rind}).
\item Both of the fields \texttt{PointList} and \texttt{PointRange}
      are optional. Only one of these two fields may be specified.
\item The structure parameter \texttt{DataType} must be consistent
      with the data stored in the \texttt{DataArray\_t} structure
      entities (see \autoref{s:DataArray}); \texttt{DataType} is
      \texttt{real} for all flow-solution identifiers defined in
      \hyperref[s:dataname]{Appendix~\ref*{s:dataname}}.
\item For unstructured zones \texttt{GridLocation} options are limited
      to \texttt{Vertex} or \texttt{CellCenter}, unless one of
      \texttt{PointList} or \texttt{PointRange} is present.
\item Indexing of data within the \texttt{DataArray\_t} structures must
      be consistent with the associated numbering of vertices or elements.
\end{notes}

|FlowSolution_t| requires four structure parameters; |CellDimension|
identifies the dimensionality of cells or elements, |IndexDimension|
identifies the dimensionality of the grid-size arrays, and |VertexSize|
and |CellSize| are the number of core vertices and cells, respectively,
in each index direction.
For unstructured zones, \fort{IndexDimension} is always 1.

The flow solution data is stored in the list of |DataArray_t| entities;
each |DataArray_t| structure entity may contain a single component of
the solution vector.
Standardized data-name identifiers for the flow-solution quantities are
described in \hyperref[s:dataname]{Appendix~\ref*{s:dataname}}.
The field |GridLocation| specifies the location of the solution data
with respect to the grid; if absent, the data is assumed to coincide
with grid vertices (i.e., |GridLocation| |=| |Vertex|).
All data within a given instance of |FlowSolution_t| must reside at the
same grid location.

For structured grids, the value of |GridLocation| alone specifies the location
and indexing of the flow solution data.  Vertices are explicity indexed.  Cell
centers and face centers are indexed using the minimum of the connecting vertex
indices, as described in the section Structured Grid Notation and Indexing
Conventions (\autoref{s:structgrid}).

For unstructured grids, the value of |GridLocation| alone specifies location and
indexing of flow solution data only for vertex and cell-centered data.  The
reason for this is that element-based grid connectivity provided in the
\texttt{Elements\_t} data structures explicitly indexes only vertices and cells.
For data stored at alternate grid locations (e.g. edges), additional
connectivity information is needed.  This is provided by the optional fields
\texttt{PointRange} and \texttt{PointList}; these refer to
vertices, edges, faces or cell centers, depending on the values of
\texttt{CellDimension} and \texttt{GridLocation}.  The following table shows
these relations.

\begin{center}
\begin{tabular}{||c|c|c|c|c||}
 \hline
\texttt{CellDimension} & \multicolumn{4}{c||}{\texttt{GridLocation}} \\
& \texttt{Vertex} & \texttt{EdgeCenter} & \texttt{*FaceCenter} & \texttt{CellCenter} \\
 \hline
1 & vertices & $-$ & $-$ & cells (line elements) \\
2 & vertices & edges & $-$ & cells (area elements) \\
3 & vertices & edges & faces & cells (volume elements) \\
 \hline
\end{tabular}
\end{center}

In the table, \fort{*FaceCenter} stands for the possible types: \fort{FaceCenter},
\fort{IFaceCenter}, \fort{JFaceCenter} or \fort{KFaceCenter}.

Although intended for edge or face-based solution data for unstructured grids,
the fields \texttt{PointRange/List} may also be used to (redundantly) index
vertex and cell-centered data.  In all cases, indexing of flow solution data
corresponds to the element numbering as defined in the \texttt{Elements\_t} data
structures.

\texttt{Rind} is an optional field that indicates
the number of rind planes (for structured grids) or rind points or
elements (for unstructured grids) included in the data.
Its purpose and function are identical to those described in
\autoref{s:Grid}.
Note, however, that the \texttt{Rind} in this structure is independent
of the \texttt{Rind} contained in \texttt{GridCoordinates\_t}.
They are not required to contain the same number of rind planes or
elements.
Also, the location of any flow-solution rind points is assumed to be
consistent with the location of the core flow solution points (e.g.,
if \texttt{GridLocation = CellCenter}, rind points are assumed to be
located at fictitious cell centers).

|DataClass| defines the default class for data contained in the
|DataArray_t| entities.  For dimensional flow solution data,
|DimensionalUnits| may be used to describe the system of units employed.
If present these two entities take precedence over the corresponding entities
at higher levels of the CGNS hierarchy.  The rules for determining precedence
of entities of this type are discussed in \autoref{s:precedence}.

The \fort{UserDefinedData\_t} data structure allows arbitrary
user-defined data to be stored in \fort{Descriptor\_t} and
\fort{DataArray\_t} children without the restrictions or implicit
meanings imposed on these node types at other node locations.

\subsubsection*{FUNCTION \texttt{ListLength[]}:}

\noindent return value: |int| \\
\noindent dependencies: |PointRange|, |PointList|

\fort{FlowSolution\_t} requires the structure function \fort{ListLength}, which
is used to specify the number of entities (e.g. vertices) corresponding to a
given \fort{PointRange} or \fort{PointList}. If
\fort{PointRange} is specified, then \fort{ListLength} is obtained from
the number of points (inclusive) between the beginning and ending indices of
\fort{PointRange}. If \fort{PointList} is specified, then
\fort{ListLength} is the number of indices in the list of points. In this
situation, \fort{ListLength} becomes a user input along with the indices of the
list \fort{PointList}. By ``user'' we mean the application code that is
generating the CGNS database.

%\noindent {\bf FUNCTION} |DataSize[]|:
\subsubsection*{FUNCTION \texttt{DataSize[]}:}

\noindent return value: one-dimensional |int| array of length
                        |IndexDimension| \\
\noindent dependencies: |IndexDimension|, |VertexSize[]|, |CellSize[]|,
                        |GridLocation|, |Rind|, |ListLength[]|

The function |DataSize[]| is the size of flow solution data arrays.
If |Rind| is absent then |DataSize| represents only the core points;
it will be the same as |VertexSize| or |CellSize| depending on
|GridLocation|.
The definition of the function |DataSize[]| is as follows:
\begin{alltt}
  if (PointRange/PointList is present) then
    \{
    DataSize[] = ListLength[] ;
    \}
  else if (Rind is absent) then
    \{
    if (GridLocation = Vertex) or (GridLocation is absent)
      \{
      DataSize[] = VertexSize[] ;
      \}
    else if (GridLocation = CellCenter) then
      \{
      DataSize[] = CellSize[] ;
      \}
    \}
  else if (Rind is present) then
    \{
    if (GridLocation = Vertex) or (GridLocation is absent) then
      \{
      DataSize[] = VertexSize[] + [a + b,...] ;
      \}
    else if (GridLocation = CellCenter)
      \{
      DataSize[] = CellSize[] + [a + b,...] ;
      \}
    \}
\end{alltt}
where |RindPlanes = [a,b,...]| (see \autoref{s:Rind} 
for the definition of |RindPlanes|). 

\subsection{Flow Solution Example}
\label{s:flow_example}

This section contains an example of the flow solution entity, including
the designation of grid location and rind planes and data-normalization
mechanisms.

\begin{example}{Flow Solution}
\label{ex:flow}

Conservation-equation variables ($\rho$, $\rho u$, $\rho v$ and
$\rho e_0$) for a 2-D grid of size $11\times5$.
The flowfield is cell-centered with two planes of rind data.
The density, momentum and stagnation energy ($\rho e_0$) data is
nondimensionalized with respect to a freestream reference state whose
quantities are dimensional.
The freestream density and pressure are used for normalization; these
values are 1.226 kg/m\tsup{3} and $1.0132 \!\times\! 10^{5}$ N/m\tsup{2}
(standard atmosphere conditions).
The data-name identifier conventions for the conservation-equation
variables are \texttt{Density}, \texttt{MomentumX}, \texttt{MomentumY} and
\texttt{EnergyStagnationDensity}.
\begin{alltt}
  !  CellDimension = 2
  !  IndexDimension = 2
  !  VertexSize = [11,5]
  !  CellSize = [10,4]
  FlowSolution\_t<2, [11,5], [10,4]> FlowExample =
    \{\{
    GridLocation\_t GridLocation = CellCenter ;

    Rind\_t<2> Rind =
      \{\{
      int[4] RindPlanes = [2,2,2,2] ;
      \}\} ;

    DataClass\_t DataClass = NormalizedByDimensional ;
    
    DimensionalUnits\_t DimensionalUnits = 
      \{\{ 
      MassUnits        = Kilogram ;
      LengthUnits      = Meter ;
      TimeUnits        = Second ;
      TemperatureUnits = TemperatureUnitsNull ;
      AngleUnits       = AngleUnitsNull ;
      \}\} ;

    !  DataType = real
    !  Dimension = 2
    !  DataSize = CellSize + [4,4] = [14,8]
    DataArray\_t<real, 2, [14,8]> Density =
      \{\{
      Data(real, 2, [14,8]) = ((rho(i,j), i=-1,12), j=-1,6) ;

      DataConversion\_t DataConversion =
        \{\{
        ConversionScale  = 1.226 ;
        ConversionOffset = 0 ;
        \}\} ;

      DimensionalExponents\_t DimensionalExponents =
        \{\{
        MassExponent        = +1 ;
        LengthExponent      = -3 ;
        TimeExponent        =  0 ;
        TemperatureExponent =  0 ;
        AngleExponent       =  0 ;
        \}\} ;
      \}\} ;

    DataArray\_t<real, 2, [14,8]> MomentumX =
      \{\{
      Data(real, 2, [14,8]) = ((rho\_u(i,j), i=-1,12), j=-1,6) ;

      DataConversion\_t DataConversion =
        \{\{
        ConversionScale  = 352.446 ;
        ConversionOffset = 0 ;
        \}\} ;
      \}\} ;

    DataArray\_t<real, 2, [14,8]> MomentumY =
      \{\{
      Data(real, 2, [14,8]) = ((rho\_v(i,j), i=-1,12), j=-1,6) ;

      DataConversion\_t DataConversion =
        \{\{
        ConversionScale  = 352.446 ;
        ConversionOffset = 0 ;
        \}\} ;
      \}\} ;

    DataArray\_t<real, 2, [14,8]> EnergyStagnationDensity =
      \{\{
      Data(real, 2, [14,8]) = ((rho\_e0(i,j), i=-1,12), j=-1,6) ;

      DataConversion\_t DataConversion =
        \{\{
        ConversionScale  = 1.0132e+05 ;
        ConversionOffset = 0 ;
        \}\} ;
      \}\} ;
    \}\} ;
\end{alltt}
The value of |GridLocation| indicates the data is at cell centers, and the
value of |RindPlanes| specifies two rind planes on each face of the zone.
The resulting value of the structure function |DataSize| is the number of
cells plus four in each coordinate direction; this value is passed to each
of the |DataArray_t| entities.

Since the data are all nondimensional and normalized by dimensional
reference quantities, this information is stated in |DataClass| and 
|DimensionalUnits| at the |FlowSolution_t| level rather than attaching
the appropriate |DataClass| and |DimensionalUnits| to each |DataArray_t|
entity.
It could possibly be at even higher levels in the heirarchy.
The contents of |DataConversion| are in each case the denominator of the
normalization; this is $\rho_\infty$ for density,
$\sqrt{p_\infty \rho_\infty}$ for momentum, and $p_\infty$ for
stagnation energy.
The dimensional exponents are specified for density.
For all the other data, the dimensional exponents are to be inferred from
the data-name identifiers.

Note that no information is provided to identify the actual reference
state or indicate that it is freestream.  This information is not needed
for data manipulations involving renormalization or changing the units
of the converted raw data.
\end{example}

\subsection{Zone Subregion Structure Definition: \texttt{ZoneSubRegion\_t}}
\label{s:ZoneSubRegion}

The \texttt{ZoneSubRegion\_t} node allows for the ability to give flowfield or
other information over a subset of the entire zone in a CGNS file.
This subset may be over a portion of a boundary, or it may be over a portion
of the entire field.

\begin{alltt}
  ZoneSubRegion\_t< int IndexDimension, int CellDimension > :=
    \{
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)
    List( Descriptor\_t Descriptor1 ... DescriptorN ) ;                      (o)

    int RegionCellDimension ;                                               (o/d)

    GridLocation\_t GridLocation ;                                           (o/d)

    IndexRange\_t<IndexDimension> PointRange ;                               (r:o:o:o)
    IndexArray\_t<IndexDimension, ListLength, int> PointList ;               (o:r:o:o)
    Descriptor\_t BCRegionName ;                                             (o:o:r:o)
    Descriptor\_t GridConnectivityRegionName ;                               (o:o:o:r)

    Rind\_t<IndexDimension> Rind;                                            (o/d)

    List( DataArray\_t<DataType, 1, ListLength[]> 
          DataArray1 ... DataArrayN ) ;                                     (o)

    FamilyName\_t FamilyName ;                                               (o)

    DataClass\_t DataClass ;                                                 (o)

    DimensionalUnits\_t DimensionalUnits ;                                   (o)

    List( UserDefinedData\_t UserDefinedData1 ... UserDefinedDataN ) ;       (o)
    \} ;
\end{alltt}

\begin{notes}
\item Default names for the
      \texttt{Descriptor\_t},
      \texttt{DataArray\_t}, and
      \texttt{UserDefinedData\_t}
      lists are as shown; users may choose other legitimate names.
      Legitimate names must be unique within a given instance of
      \texttt{ZoneSubRegion\_t} and shall not include the names
      \texttt{RegionCellDimension}, \texttt{Rind}, \texttt{PointRange},
      \texttt{PointList}, \texttt{BCRegionName}, \texttt{GridConnectivityRegionName},
      \texttt{FamilyName}, \texttt{DataClass} or \texttt{DimensionalUnits}.
\item \texttt{RegionCellDimension} must be equal to or less than the
      cell dimension for the zone. If absent, then its default value is
      \texttt{CellDimension}.
\item \texttt{GridLocation} has a default value of \texttt{Vertex} if absent.
      Permissible values of \texttt{GridLocation} are determined by
      \texttt{RegionCellDimension} (see below). All data within a given
      instance of \texttt{ZoneSubRegion\_t} must reside at the same grid location.
\item The extent of the region and distribution of its data is specified by one of
      \texttt{PointRange}, \texttt{PointList}, \texttt{BCRegionName}, or
      \texttt{GridConnectivityRegionName}. One and only one of these must be specified.
\end{notes}

The extent of the subregion and the distribution of data within that subregion
is determined by \texttt{RegionCellDimension}, \texttt{GridLocation}, and one of
\texttt{PointRange/List}, \texttt{BCRegionName}, or \texttt{GridConnectivityRegionName}.
For a 3-D subregion (\texttt{RegionCellDimension} = 3), data can be located
at vertices, edges, face centers or cell centers.
For a 2-D subregion (\texttt{RegionCellDimension} = 2),
data can be located at vertices, edges or cell centers (i.e. area elements).
It is anticipated that one of the widest uses for \texttt{ZoneSubRegion\_t}
will be to store specific boundary-only information. For example, in a 3-D simulation,
one may wish to store additional data on surfaces. In this case, the
\texttt{RegionCellDimension} would be set to 2.

\texttt{PointRange/List} refer to vertices, edges, faces or cell centers,
depending on the values of \texttt{RegionCellDimension} and \texttt{GridLocation}.
Note that it is both the dimensionality of the zone (\texttt{CellDimension})
as well as the dimensionality of the subregion (\texttt{RegionCellDimension}),
that determines the types of elements
permissible in \texttt{PointRange/List}. The following table shows these relations.

\begin{center}
\begin{tabular}{||c|c|c|c|c|c||}
 \hline
\texttt{CellDimension} & {RegionCellDimension} & \multicolumn{4}{c||}{\texttt{GridLocation}} \\
& & \texttt{Vertex} & \texttt{EdgeCenter} & \texttt{*FaceCenter} & \texttt{CellCenter} \\
 \hline
1 & 1 & vertices & $-$ & $-$ & cells (line elements) \\ \hline
2 & 1 & vertices & edges & $-$ & $-$ \\
2 & 2 & vertices & edges & $-$ & cells (area elements) \\ \hline
3 & 1 & vertices & edges & $-$ & $-$ \\
3 & 2 & vertices & edges & faces & $-$ \\
3 & 3 & vertices & edges & faces & cells (volume elements) \\
 \hline
\end{tabular}
\end{center}

In the table, \fort{*FaceCenter} stands for the possible types: \fort{FaceCenter},
\fort{IFaceCenter}, \fort{JFaceCenter} or \fort{KFaceCenter}.

For both structured and unstructured grids, \texttt{GridLocation} = \texttt{Vertex}
means that \texttt{PointRange/List} refers to vertex indices. For structured grids,
edges, faces and cell centers are indexed using the minimum of the
connecting vertex indices, as described in the section
Structured Grid Notation and Indexing Conventions (\autoref{s:structgrid}).
For unstructured grids, edges, faces and
cell centers are indexed using their element numbering, as defined in
the \texttt{Elements\_t} data structures (\autoref{s:Elements}).

If the vertices or elements of the subregion are continuously numbered,
then \texttt{PointRange} may be used. Otherwise, \texttt{PointList}
should be used to list the vertices/elements. Alternatively, if
the data locations and range of the subregion coincide with an existing
BC region or zone-to-zone GridConnectivity region, then \texttt{BCRegionName}
or \texttt{GridConnectivityRegionName} may be used.
\texttt{BCRegionName} is a string giving the name of an existing
\texttt{BC\_t} node of the current zone.
\texttt{GridConnectivityRegionName} is a string giving the name of an existing
\texttt{GridConnectivity1to1\_t}
or \texttt{GridConnectivity\_t}
node of the current zone.
The name referred to should be unambiguous.

Consistent with \texttt{FlowSolution\_t},
the subregion's solution data is stored in the list of
\texttt{DataArray\_t} entities;
each \texttt{DataArray\_t} structure entity contains a single quantity.
Standardized data-name identifiers for solution quantities are described
in the section Conventions for Data-Name Identifiers (\autoref{s:dataname}).
As noted above, all solution data
within a given subregion must reside at the same grid location.

\texttt{DataClass} defines the default class
for data contained in the \texttt{DataArray\_t} entities. For dimensional
flow solution data, \texttt{DimensionalUnits}
may be used to describe the system of units employed. If present, these two entities
take precedence over the corresponding entities at higher levels of the
CGNS hierarchy, following the standard precedence rules (\autoref{s:precedence}).

\texttt{ZoneSubRegion\_t} requires the structure function
\texttt{ListLength[]},
which is used to specify the number
of data points (e.g. vertices, cell centers, face centers, edge centers)
corresponding to the given \texttt{PointRange/List}.
If \texttt{PointRange} is specified, then \texttt{ListLength} is obtained
from the number of points (inclusive) between the beginning and ending indices
of \texttt{PointRange}. If \texttt{PointList} is specified,
then \texttt{ListLength} is the number of indices in the list of points.
In this situation, \texttt{ListLength} becomes a user input along with the
indices of the list \texttt{PointList}. By ``user'' we mean the application
code that is generating the CGNS database.

\texttt{Rind} is an optional field that indicates the
number of rind planes (for structured grids) or rind points (for unstructured grids).
If \texttt{Rind} is absent, then the \texttt{DataArray\_t} structure entities contain
only core data of length \texttt{ListLength}, as defined for this region.
If \texttt{Rind} is present, it will provide information on the number of
rind elements, in addition to the \texttt{ListLength}, that are contained
in the \texttt{DataArray\_t} structures. The bottom line is that \texttt{Rind}
simply adds a specified number to \texttt{ListLength},
as used by the \texttt{DataArray\_t} structures.

The \texttt{UserDefinedData\_t} data structure
allows arbitrary user-defined data to be stored.

There may be multiple instances of \texttt{ZoneSubRegion\_t} in a given zone.
These may simply be multiple regions defined for a single solution,
or they may be associated with different times / different solutions in a
time-dependent simulation (in which case
\texttt{ZoneIterativeData} (\autoref{s:ZoneIterativeData}) should be
used to associate them).

\subsection{Zone Subregion Examples}
\label{s:zonesubregion_examples}

This section contains four examples of Zone Subregions, including
the use of \texttt{PointList}, \texttt{PointRange} and \texttt{BCRegionName}.

\begin{example}{Volume Subregion for a Structured Grid}
\label{ex:zonesubregion1}

For this example, it is assumed that a 1-zone 3-D structured grid exists
of size ($197 \times 97 \times 33$). Inside of this zone, the user wishes to output a
special subset region of interior data (say, temperature and kinematic viscosity)
at the specific cell-center locations i = 121-149, j = 17-45, k = 21-23.
Even though this same data may possibly exist under \texttt{FlowSolution\_t}
(which holds the flowfield data for the entire zone), this particular location
may represent a special region of interest where the user wants to focus attention
or output different types of flowfield variables or user-defined data.
Note that for structured grids, the location list always references grid nodes;
in this case with \texttt{GridLocation} = \texttt{Cellcenter} the cell centers
are indexed by the minimum i, j, and k indices of the connecting vertices.

\begin{alltt}
Under Zone\_t:

  ZoneSubRegion\_t<3,3> Region1 =
    \{\{
    GridLocation\_t GridLocation = CellCenter ;
    int RegionCellDimension = 3;
    IndexRange\_t<3> PointRange =
      \{\{
      int[3] Begin = [121,17,21];
      int[3] End = [149,45,21];
      \}\};

    ! ListLength = (149-121+1)*(45-17+1)*(23-21+1) = 29*29*3 = 2523
    DataArray\_t<real,1,2523> Temperature =
      \{\{
      Data(real,1,2523) = temperature at the cell centers specified
      \}\} ;
    DataArray\_t<real,1,2523> ViscosityKinematic =
      \{\{
      Data(real,1,2523) = kinematic viscosity at the cell centers specified
      \}\} ;
    \}\} ; ! end Region1
\end{alltt}

\end{example}

\begin{example}{Volume Subregion for an Unstructured Grid}
\label{ex:zonesubregion2}

This example is like the previous one, except it is for an unstructured zone.
Inside of this zone, the user wishes to output a special subset region of
data (say, temperature and kinematic viscosity) at a specific list of 2523
element cell-center locations, located somewhere within the (larger) field
of elements. Recall that when \texttt{GridLocation} is anything other than
\texttt{Vertex} in conjunction with unstructured grids, then the location list
represents element numbers and not grid node numbers.

\begin{alltt}
Under Zone\_t:

  ZoneSubRegion\_t<1,3> Region1 =
    \{\{
    GridLocation\_t GridLocation = CellCenter ;
    int RegionCellDimension = 3;
    IndexArray\_t<1,2523,int> PointList =
      \{\{
      int[1] ElementList = list of 3-D element numbers where region data given
      \}\} ;

    ! ListLength = length of the element list = 2523
    DataArray\_t<real,1,2523> Temperature =
      \{\{
      Data(real,1,2523) = temperature at the element cell centers specified
      \}\} ;
    DataArray\_t<real,1,2523> ViscosityKinematic =
      \{\{
      Data(real,1,2523) = kinematic viscosity at the element cell centers specified
      \}\} ;
    \}\} ; ! end Region1
\end{alltt}

\end{example}

\begin{example}{Surface Subregion for an Unstructured Grid}
\label{ex:zonesubregion3}

In this example, boundary data is output on a 2-D surface subregion of a 3-D problem.
Because this is data on a topologically 2-D boundary (in a 3-D simulation),
\texttt{RegionCellDimension} is set to 2. \texttt{GridLocation} is specified as
\texttt{FaceCenter}. Recall that when \texttt{GridLocation} is anything other than
\texttt{Vertex} in conjunction with unstructured grids, then the location list
represents element numbers and not grid node numbers. Thus, the \texttt{PointList/Range}
indicates particular surface elements (or boundary elements) that need to have been
defined in the file under their own \texttt{Elements\_t} node(s),
separate from the 3-D volume elements that make up the grid.
In this case, we assume that the surface element numbers at which we are outputting
data are 5568 through 5592 inclusive. Because the numbers occur in sequential order,
we can make use of \texttt{PointRange}.

\begin{alltt}
Under Zone\_t:

  ZoneSubRegion\_t<1,3> Region1 =
    \{\{
    GridLocation\_t GridLocation = FaceCenter ;
    int RegionCellDimension = 2;
    IndexArray\_t<1,25,int> PointRange =
      \{\{
      int[1] Begin = [5568];
      int[1] End = [5592];
      \}\} ;

    ! ListLength = length of the element list = 25
    DataArray\_t<real,1,25> Temperature =
      \{\{
      Data(real,1,25) = temperature at the specific face element locations 
                        specified
      \}\} ;
    DataArray\_t<real,1,25> ViscosityKinematic =
      \{\{
      Data(real,1,25) = kinematic viscosity at the specific face element 
                        locations specified
      \}\} ;
    \}\} ; ! end Region1
\end{alltt}

\end{example}

\begin{example}{Surface Subregion Utilizing BC Information}
\label{ex:zonesubregion4}

In this example, boundary data is output at the same locations where the BCs
are specified in a particular \texttt{BC\_t} node (in this case the ListLength is 25).
Note that because this is data on a topologically 2-D boundary (in a 3-D simulation),
\texttt{RegionCellDimension} is set to 2. \texttt{GridLocation} is not specified,
because it is inherited from the \texttt{BC\_t} node along with the \texttt{ListLength}.

\begin{alltt}
Under Zone\_t:

  ZoneSubRegion\_t<1,3> Region1 =
    \{\{
    int RegionCellDimension = 2;
    Descriptor\_t BCRegionName = "name of a ZoneBC/BC\_t node" ;

    ! ListLength = length of the point/element list from BC\_t = 25
    DataArray\_t<real,1,25> Temperature =
      \{\{
      Data(real,1,25) = temperature at the specific BC locations 
                        specified
      \}\} ;
    DataArray\_t<real,1,25> ViscosityKinematic =
      \{\{
      Data(real,1,25) = kinematic viscosity at the specific BC 
                        locations specified
      \}\} ;
    \}\} ; ! end Region1
\end{alltt}

\end{example}
