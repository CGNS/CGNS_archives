\section{Solution Data}
\label{s:solution}
\thispagestyle{plain}

\subsection{Flow Solution}
\label{s:flowsolution}

\noindent
\textit{Node}: \texttt{FlowSolution\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_sol\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *solname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{output}{\textit{int *S}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nsols(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nsols}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_sol\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{output}{\textit{char *solname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{GridLocation\_t *location}}); & \\
\textcolor{output}{\textit{ier}} = cg\_sol\_ptset\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *solname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{PointSetType\_t ptset\_type}, & \\
~~~~~~\textcolor{input}{cgsize\_t npnts}, \textcolor{input}{cgsize\_t *pnts}, \textcolor{output}{\textit{int *S}}); & \\
\textcolor{output}{\textit{ier}} = cg\_sol\_ptset\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, & r - m \\
~~~~~~\textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, \textcolor{output}{\textit{cgsize\_t *npnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_sol\_ptset\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{output}{\textit{cgsize\_t *pnts}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_sol\_size(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{output}{\textit{int *data\_dim}}, & r - m \\
~~~~~~\textcolor{output}{\textit{cgsize\_t *dim\_vals}}); & \\
\hline
call cg\_sol\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{solname}, \textcolor{input}{location}, \textcolor{output}{\textit{S}}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_nsols\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nsols}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_sol\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{solname}}, \textcolor{output}{\textit{location}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_sol\_ptset\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{solname}, \textcolor{input}{location}, \textcolor{input}{ptset\_type}, & - w m \\
~~~~~\textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{output}{\textit{S}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_sol\_ptset\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{ptset\_type}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_sol\_ptset\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{pnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_sol\_size\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{data\_dim}}, \textcolor{output}{\textit{dim\_vals}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{ptset\_type}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{S}]
      Flow solution index number, where $1 \leq \text{\texttt{S}} \leq \text{\texttt{nsols}}$.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_info};
      \textcolor{output}{\textit{output}} for \texttt{cg\_sol\_write})
\item [\texttt{nsols}]
      Number of flow solutions for zone \texttt{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{solname}]
      Name of the flow solution.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_sol\_info})
\item [\texttt{location}]
      Grid location where the solution is recorded.
      The current admissible locations are \texttt{Vertex},
      \texttt{CellCenter}, \texttt{IFaceCenter}, \texttt{JFaceCenter},
      and \texttt{KFaceCenter}.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_write} and
      \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_sol\_info})
\item [\texttt{ptset\_type}]
      Type of point set defining the interface in the current solution;
      either \texttt{PointRange} or \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_info})
\item [\texttt{npnts}]
      Number of points defining the interface in the current solution.
      For a \texttt{ptset\_type} of \texttt{PointRange}, npnts
      is always two. For a \texttt{ptset\_type} of \texttt{PointList},
      npnts is the number of points in the list. 
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_info})
\item [\texttt{pnts}]
      Array of points defining the interface in the current solution.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_read})
\item [\texttt{data\_dim}]
      Number of dimensions defining the solution data.
      If a point set has been defined, this will be 1,
      otherwise this will be the current zone index dimension.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{dim\_vals}]
      The array of \texttt{data\_dim} dimensions for the solution data.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions are used to create, and get information about,
\texttt{FlowSolution\_t} nodes.

Solution data may be specified over the entire zone, as in previous
versions of the library, using \texttt{cg\_sol\_write} or over
a patch region of the zone using \texttt{cg\_sol\_ptset\_write}.
The two are mutually exclusive. In the first case, the size of
the solution data is determined by the size of the zone, the
grid location, and rind data (if any) as in previous versions.
In the second case the solution data size is entirely determined
by the \texttt{PointList/PointRange} patch. In order to determine which of
the two forms in which the solution data was written, use
\texttt{cg\_sol\_ptset\_info}. If the solution is over the entire
zone, \texttt{ptset\_type} will be returned as \texttt{CG\_Null}
and \texttt{npnts} as 0. Otherwise, \texttt{ptset\_type} will
be either \texttt{PointList} or \texttt{PointRange}, and the
number of points will be returned in \texttt{npnts}.

To assist in determining the size of the solution data,
the function \texttt{cg\_sol\_size} has been added. For a solution
defined over the full zone, \texttt{data\_dim} returns the index
dimension for the zone, and \texttt{dim\_vals} specifies the
dimensions of the data, corrected for the grid location type
and rind data. If a point set patch has been specified,
\texttt{data\_dim} will be 1 and \texttt{dim\_vals} will contain
the total size of the patch.

Acceptable values of \texttt{GridLocation\_t} are \texttt{Vertex}
and \texttt{CellCenter}. If the base cell dimension is 2 or
greater (surface or volume), then \texttt{EdgeCenter} is
also allowed. For 3 dimensional bases, \texttt{FaceCenter}, and
for structured zones, \texttt{IFaceCenter}, \texttt{JFaceCenter}
and \texttt{KFaceCenter}, are also acceptable.

\newpage
\subsection{Flow Solution Data}
\label{s:flowsolutionarray}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_field\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{input}{DataType\_t datatype}, & - w m \\
~~~~~~\textcolor{input}{char *fieldname}, \textcolor{input}{void *solution\_array}, \textcolor{output}{\textit{int *F}}); & \\
\textcolor{output}{\textit{ier}} = cg\_field\_partial\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, & - w m \\
~~~~~~\textcolor{input}{DataType\_t datatype}, \textcolor{input}{char *fieldname}, \textcolor{input}{cgsize\_t *range\_min}, & \\
~~~~~~\textcolor{input}{cgsize\_t *range\_max}, \textcolor{input}{void *solution\_array}, \textcolor{output}{\textit{int *F}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nfields(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{output}{\textit{int *nfields}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_field\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{input}{int F}, & r - m \\
~~~~~~\textcolor{output}{\textit{DataType\_t *datatype}}, \textcolor{output}{\textit{char *fieldname}}); & \\
\textcolor{output}{\textit{ier}} = cg\_field\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{input}{char *fieldname}, & r - m \\
~~~~~~\textcolor{input}{DataType\_t datatype}, \textcolor{input}{cgsize\_t *range\_min}, \textcolor{input}{cgsize\_t *range\_max}, & \\
~~~~~~\textcolor{output}{\textit{void *solution\_array}}); & \\
\hline
call cg\_field\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{input}{datatype}, \textcolor{input}{fieldname}, \textcolor{input}{solution\_array}, & - w m \\
~~~~~\textcolor{output}{\textit{F}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_field\_partial\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{input}{datatype}, \textcolor{input}{fieldname}, & - w m \\
~~~~~\textcolor{input}{range\_min}, \textcolor{input}{range\_max}, \textcolor{input}{solution\_array}, \textcolor{output}{\textit{F}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_nfields\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{nfields}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_field\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{input}{F}, \textcolor{output}{\textit{datatype}}, \textcolor{output}{\textit{fieldname}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_field\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{input}{fieldname}, \textcolor{input}{datatype}, \textcolor{input}{range\_min}, & r - m \\
~~~~~\textcolor{input}{range\_max}, \textcolor{output}{\textit{solution\_array}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{solution\_array}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{S}]
      Flow solution index number, where $1 \leq \text{\texttt{S}} \leq \text{\texttt{nsols}}$.
      (\textcolor{input}{Input})
\item [\texttt{F}]
      Solution array index number, where $1 \leq \text{\texttt{F}} \leq \text{\texttt{nfields}}$.
      (\textcolor{input}{Input} for \texttt{cg\_field\_info};
      \textcolor{output}{\textit{output}} for \texttt{cg\_field\_write})
\item [\texttt{nfields}]
      Number of data arrays in flow solution \texttt{S}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{datatype}]
      Data type in which the solution array is written.
      Admissible data types for a solution array are \texttt{Integer},
      \texttt{LongInteger}, \texttt{RealSingle}, and \texttt{RealDouble}.
      (\textcolor{input}{Input} for \texttt{cg\_field\_write},
      \texttt{cg\_field\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_field\_info})
\item [\texttt{fieldname}]
      Name of the solution array.
      It is strongly advised to use the SIDS nomenclature conventions
      when naming the solution arrays to insure file compatibility.
      (\textcolor{input}{Input} for \texttt{cg\_field\_write},
      \texttt{cg\_field\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_field\_info})
\item [\texttt{range\_min}]
      Lower range index (eg., \texttt{imin, jmin, kmin}).
      (\textcolor{input}{Input})
\item [\texttt{range\_max}]
      Upper range index (eg., \texttt{imax, jmax, kmax}).
      (\textcolor{input}{Input})
\item [\texttt{solution\_array}]
      Array of solution values for the range prescribed.
      (\textcolor{input}{Input} for \texttt{cg\_field\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_field\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions are used to read and write solution arrays stored
below a \texttt{FlowSolution\_t} node.

When writing, the function \texttt{cg\_field\_write} will
automatically write the full range of the solution (i.e., the entire
\texttt{solution\_array}).
The function \texttt{cg\_field\_partial\_write} may be used to write
only a subset of \texttt{solution\_array}.
When using the partial write, any existing data from \texttt{range\_min}
to \texttt{range\_max} will be overwritten by the new values.
All other values will not be affected.

The function \texttt{cg\_field\_read} returns the solution array
\texttt{fieldname}, for the range prescribed by \texttt{range\_min} and
\texttt{range\_max}.
The array is returned to the application in the data type requested in
\texttt{datatype}.
This data type does not need to be the same as the one in which the data is
stored in the file.
A solution array stored as double precision in the CGNS file can be
returned to the application as single precision, or vice versa.

In Fortran, when using \texttt{cg\_field\_read\_f} to read a 2D or 3D
solution, the extent of each dimension of \texttt{solution\_array} must
be consistent with the requested range.
When reading a 1D solution, the declared size can be larger than the
requested range.
For example, for a 2D zone with $100 \times 50$ vertices, if
\texttt{range\_min} and \texttt{range\_max} are set to (11,11) and (20,20)
to read a subset of the solution, then \texttt{solution\_array} must be
dimensioned (10,10).
If \texttt{solution\_array} is declared larger (e.g., (100,50)) the
indices for the returned array values will be wrong.

\newpage
\subsection{Discrete Data}
\label{s:discretedata}

\noindent
\textit{Node}: \texttt{DiscreteData\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_discrete\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *DiscreteName}, & - w m \\
~~~~~~\textcolor{output}{\textit{int *D}}); & \\
\textcolor{output}{\textit{ier}} = cg\_ndiscrete(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *ndiscrete}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_discrete\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int D}, & r - m \\
~~~~~~\textcolor{output}{\textit{char *DiscreteName}}); & \\
\textcolor{output}{\textit{ier}} = cg\_discrete\_ptset\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *DiscreteName}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{PointSetType\_t ptset\_type}, & \\
~~~~~~\textcolor{input}{cgsize\_t npnts}, \textcolor{input}{cgsize\_t *pnts}, \textcolor{output}{\textit{int *D}}); & \\
\textcolor{output}{\textit{ier}} = cg\_discrete\_ptset\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int D}, & r - m \\
~~~~~~\textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, \textcolor{output}{\textit{cgsize\_t *npnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_discrete\_ptset\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int D}, & r - m \\
~~~~~~\textcolor{output}{\textit{cgsize\_t *pnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_discrete\_size(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int D}, \textcolor{output}{\textit{int *data\_dim}}, & r - m \\
~~~~~~\textcolor{output}{\textit{cgsize\_t *dim\_vals}}); & \\
\hline
call cg\_discrete\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{DiscreteName}, \textcolor{output}{\textit{D}}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_ndiscrete\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{ndiscrete}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_discrete\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{D}, \textcolor{output}{\textit{DiscreteName}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_discrete\_ptset\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{DiscreteName}, \textcolor{input}{location}, & - w m \\
~~~~~\textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{output}{\textit{D}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_discrete\_ptset\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{D}, \textcolor{output}{\textit{ptset\_type}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_discrete\_ptset\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{D}, \textcolor{output}{\textit{pnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_discrete\_size\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{D}, \textcolor{output}{\textit{data\_dim}}, \textcolor{output}{\textit{dim\_vals}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{DiscreteName}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{D}]
      Discrete data index number, where $1 \leq \text{\texttt{D}} \leq \text{\texttt{ndiscrete}}$.
      (\textcolor{input}{Input} for \texttt{cg\_discrete\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_discrete\_write})
\item [\texttt{ndiscrete}]
      Number of \texttt{DiscreteData\_t} data structures under zone \texttt{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{DiscreteName}]
      Name of \texttt{DiscreteData\_t} data structure.
      (\textcolor{input}{Input} for \texttt{cg\_discrete\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_discrete\_read})
\item [\texttt{location}]
      Grid location where the discrete data is recorded.
      The current admissible locations are \texttt{Vertex},
      \texttt{CellCenter}, \texttt{IFaceCenter}, \texttt{JFaceCenter},
      and \texttt{KFaceCenter}.
      (\textcolor{input}{Input} for \texttt{cg\_discrete\_ptset\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_sol\_info})
\item [\texttt{ptset\_type}]
      Type of point set defining the interface for the discrete data;
      either \texttt{PointRange} or \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_info})
\item [\texttt{npnts}]
      Number of points defining the interface for the discrete data.
      For a \texttt{ptset\_type} of \texttt{PointRange}, npnts
      is always two. For a \texttt{ptset\_type} of \texttt{PointList},
      npnts is the number of points in the list. 
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_info})
\item [\texttt{pnts}]
      Array of points defining the interface for the discrete data.
      (\textcolor{input}{Input} for \texttt{cg\_sol\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_sol\_ptset\_read})
\item [\texttt{data\_dim}]
      Number of dimensions defining the discrete data.
      If a point set has been defined, this will be 1,
      otherwise this will be the current zone index dimension.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{dim\_vals}]
      The array of \texttt{data\_dim} dimensions for the discrete data.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

\texttt{DiscreteData\_t} nodes are intended for the storage of fields
of data not usually identified as part of the flow solution, such as
fluxes or equation residuals.

The description for these functions is similar to the
\texttt{FlowSolution\_t} node (\autoref{s:flowsolution}).
To read and write the discrete data, use
\texttt{cg\_goto} (\autoref{s:navigating}) to access the
\texttt{DiscreteData\_t} node, then
\texttt{cg\_array\_read} and \texttt{cg\_array\_write} (\autoref{s:dataarray}).

\newpage
\subsection{Zone Subregions}
\label{s:subregion}

\noindent
\textit{Node}: \texttt{ZoneSubRegion\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_nsubregs(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nsubregs}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, \textcolor{output}{\textit{char *regname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{int *dimension}}, \textcolor{output}{\textit{GridLocation\_t *location}}, & \\
~~~~~~\textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, \textcolor{output}{\textit{cgsize\_t *npnts}}, & \\
~~~~~~\textcolor{output}{\textit{int *bcname\_len}}, \textcolor{output}{\textit{int *bcname\_len}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_ptset\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, & r - m \\
~~~~~~\textcolor{output}{\textit{cgsize\_t *pnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_bcname\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, & r - m \\
~~~~~~\textcolor{output}{\textit{char *bcname}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_gcname\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int S}, & r - m \\
~~~~~~\textcolor{output}{\textit{char *gcname}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_ptset\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{const char *regname}, & - w m \\
~~~~~~\textcolor{input}{int dimension}, \textcolor{input}{GridLocation\_t location}, & \\
~~~~~~\textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{cgsize\_t npnts}, & \\
~~~~~~\textcolor{input}{cgsize\_t *pnts}, \textcolor{output}{\textit{int *S}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_bcname\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{const char *regname}, & - w m \\
~~~~~~\textcolor{input}{int dimension}, \textcolor{input}{const char *bcname}, \textcolor{output}{\textit{int *S}}); & \\
\textcolor{output}{\textit{ier}} = cg\_subreg\_gcname\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{const char *regname}, & - w m \\
~~~~~~\textcolor{input}{int dimension}, \textcolor{input}{const char *gcname}, \textcolor{output}{\textit{int *S}}); & \\
\hline
call cg\_nsubregs\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nsubregs}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_subreg\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{regname}}, \textcolor{output}{\textit{dimension}}, \textcolor{output}{\textit{location}}, & r - m \\
~~~~~\textcolor{output}{\textit{ptset\_type}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{bcname\_len}}, \textcolor{output}{\textit{bcname\_len}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_subreg\_ptset\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{pnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_subreg\_bcname\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{bcname}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_subreg\_gcname\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{S}, \textcolor{output}{\textit{gcname}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_subreg\_ptset\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{regname},  \textcolor{input}{dimension}, \textcolor{input}{location}, & - w m \\
~~~~~\textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{output}{\textit{S}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_subreg\_bcname\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{regname}, \textcolor{input}{dimension}, \textcolor{input}{bcname}, & - w m \\
~~~~~\textcolor{output}{\textit{S}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_subreg\_gcname\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{regname}, \textcolor{input}{dimension}, \textcolor{input}{gcname}, & - w m \\
~~~~~\textcolor{output}{\textit{S}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{ptset\_type}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input})
\item [\texttt{S}]
      ZoneSubRegion index number, where $1 \leq \text{\texttt{S}} \leq \text{\texttt{nsubregs}}$.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_info},
      \texttt{cg\_subreg\_ptset\_read}, \texttt{cg\_subreg\_bcname\_read} and
      \texttt{cg\_subreg\_gcname\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_subreg\_ptset\_write},
      \texttt{cg\_subreg\_bcname\_write} and \texttt{cg\_subreg\_gcname\_write})
\item [\texttt{nsubregs}]
      Number of \texttt{ZoneSubRegion\_t} nodes under Zone \texttt{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{regname}]
      Name of the \texttt{ZoneSubRegion\_t} node.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write},
      \texttt{cg\_subreg\_bcname\_write}, and
      \texttt{cg\_subreg\_gcname\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_subreg\_info})
\item [\texttt{dimension}]
      Dimensionality of the subregion. 1 for lines, 2 for faces,
      3 for volumes.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write},
      \texttt{cg\_subreg\_bcname\_write}, and
      \texttt{cg\_subreg\_gcname\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_subreg\_info})
\item [\texttt{location}]
      Grid location used in the definition of the point set.
      The current admissible locations are \texttt{Vertex} and
      \texttt{CellCenter}.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_subreg\_info})
\item [\texttt{ptset\_type}]
      Type of point set defining the interface for the subregion data;
      either \texttt{PointRange} or \texttt{PointList}.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_subreg\_info})
\item [\texttt{npnts}]
      Number of points defining the interface for the subregion data.
      For a \texttt{ptset\_type} of \texttt{PointRange}, npnts
      is always two. For a \texttt{ptset\_type} of \texttt{PointList},
      npnts is the number of points in the list. 
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_subreg\_info})
\item [\texttt{pnts}]
      Array of points defining the interface for the subregion data.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_ptset\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_subreg\_ptset\_read})
\item [\texttt{bcname}]
      The name of a \texttt{BC\_t} node which defines the subregion.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_bcname\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_subreg\_bcname\_read})
\item [\texttt{gcname}]
      The name of a \texttt{GridConnectivity\_t} or
      \texttt{GridConnectivity1to1\_t} node which defines the subregion.
      (\textcolor{input}{Input} for \texttt{cg\_subreg\_gcname\_write};
      \textcolor{output}{\textit{output}} for
      \texttt{cg\_subreg\_gcname\_read})
\item [\texttt{bcname\_len}]
      String length of \texttt{bcname}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{gcname\_len}]
      String length of \texttt{gcname}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

These functions allow for the specification of Zone subregions. The
subregion may be specified as either the name of an existing
\texttt{BC\_t} node (\texttt{cg\_subreg\_bcname\_write}), an
existing \texttt{GridConnectivity\_t} or \texttt{GridConnectivity1to1\_t}
node (\texttt{cg\_subreg\_gcname\_write}), or as a
\texttt{PointSet/PointRange} (\texttt{cg\_subreg\_ptset\_write}).
These specifications are mutually exclusive.
To determine the type of the subregion, use
\texttt{cg\_subreg\_info}. If the subregion is a point set,
then \texttt{ptset\_type} will indicate the point set type (either
\texttt{PointList} or \texttt{PointRange}) and \texttt{npts} will be
set to the number of points to define the region. Otherwise,
\texttt{ptset\_type} will be set to \texttt{CG\_Null} and
\texttt{npnts} will be 0. In this case, one of \texttt{bcname\_len}
or \texttt{gcname\_len} will be non-zero, indicating whether the
subregion references a \texttt{BC\_t} node
(\texttt{bcname\_len} non-zero) or
\texttt{GridConnectivity\_t} node (\texttt{gcname\_len} non-zero).

