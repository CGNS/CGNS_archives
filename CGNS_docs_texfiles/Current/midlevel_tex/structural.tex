\section{Structural Nodes}
\label{s:structural}
\thispagestyle{plain}

\subsection{CGNS Base Information}
\label{s:base}

\noindent
\textit{Node}: \texttt{CGNSBase\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_base\_write(\textcolor{input}{int fn}, \textcolor{input}{char *basename}, \textcolor{input}{int cell\_dim}, \textcolor{input}{int phys\_dim}, & - w m \\
~~~~~~\textcolor{output}{\textit{int *B}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nbases(\textcolor{input}{int fn}, \textcolor{output}{\textit{int *nbases}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_base\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{char *basename}}, \textcolor{output}{\textit{int *cell\_dim}}, & r - m \\
~~~~~~\textcolor{output}{\textit{int *phys\_dim}}); & \\
\textcolor{output}{\textit{ier}} = cg\_cell\_dim(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{int *cell\_dim}}); & r - m \\
\hline
call cg\_base\_write\_f(\textcolor{input}{fn}, \textcolor{input}{basename}, \textcolor{input}{cell\_dim}, \textcolor{input}{phys\_dim}, \textcolor{output}{\textit{B}}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_nbases\_f(\textcolor{input}{fn}, \textcolor{output}{\textit{nbases}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_base\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{basename}}, \textcolor{output}{\textit{cell\_dim}}, \textcolor{output}{\textit{phys\_dim}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_cell\_dim\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{cell\_dim}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{basename}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input} for \texttt{cg\_base\_read};
      \textcolor{output}{\textit{output}} for \texttt{cg\_base\_write})
\item [\texttt{nbases}]
      Number of bases present in the CGNS file \texttt{fn}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{basename}]
      Name of the base.
      (\textcolor{input}{Input} for \texttt{cg\_base\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_base\_read})
\item [\texttt{cell\_dim}]
      Dimension of the cells; 3 for volume cells, 2 for surface cells
      and 1 for line cells.
      (\textcolor{input}{Input} for \texttt{cg\_base\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_base\_read}
      and \texttt{cg\_cell\_dim})
\item [\texttt{phys\_dim}]
      Number of coordinates required to define a vector in the field.
      (\textcolor{input}{Input} for \texttt{cg\_base\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_base\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

\newpage
\subsection{Zone Information}
\label{s:zone}

\noindent
\textit{Node}: \texttt{Zone\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_zone\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{char *zonename}, \textcolor{input}{cgsize\_t *size}, & - w m \\
~~~~~~\textcolor{input}{ZoneType\_t zonetype}, \textcolor{output}{\textit{int *Z}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nzones(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{int *nzones}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_zone\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{char *zonename}}, & r - m \\
~~~~~~\textcolor{output}{\textit{cgsize\_t *size}}); & \\
\textcolor{output}{\textit{ier}} = cg\_zone\_type(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{ZoneType\_t *zonetype}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_index\_dim(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *index\_dim}}); & r - m \\
\hline
call cg\_zone\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{zonename}, \textcolor{input}{size}, \textcolor{input}{zonetype}, \textcolor{output}{\textit{Z}}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_nzones\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{nzones}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_zone\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{zonename}}, \textcolor{output}{\textit{size}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_zone\_type\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{zonetype}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_index\_dim\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{index\_dim}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{index\_dim}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{Z}]
      Zone index number, where $1 \leq \text{\texttt{Z}} \leq \text{\texttt{nzones}}$.
      (\textcolor{input}{Input} for \texttt{cg\_zone\_read},
      \texttt{cg\_zone\_type}; \textcolor{output}{\textit{output}} for
      \texttt{cg\_zone\_write})
\item [\texttt{nzones}]
      Number of zones present in base \texttt{B}.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{zonename}]
      Name of the zone.
      (\textcolor{input}{Input} for \texttt{cg\_zone\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_zone\_read})
\item [\texttt{size}]
      Number of vertices, cells, and boundary vertices in each
      (\textit{index})-dimension.

      Note that for unstructured grids, the number of cells is the
      number of highest order elements.
      Thus, in three dimensions it's the number of 3-D cells, and in
      two dimensions it's the number of 2-D cells.

      Also for unstructured grids, if the nodes are sorted between
      internal nodes and boundary nodes, the optional parameter
      \texttt{NBoundVertex} must be set equal to the number of boundary
      nodes.
      By default, \texttt{NBoundVertex} equals zero, meaning that the
      nodes are unsorted.

      Note that a non-zero value for \texttt{NBoundVertex} only applies
      to unstructured grids.
      For structured grids, the \texttt{NBoundVertex} parameter always
      equals 0 in all directions.

      \setlength{\tmplength}{\extrarowheight}	% temporarily decrease row heights
      \setlength{\extrarowheight}{0pt}
      \begin{tabular}{@{}l >{\ttfamily}l}
         \uline{\ital{Mesh Type}} & \uline{\ital{Size}} \\
         3D structured     & NVertexI, NVertexJ, NVertexK \\
                           & NCellI, NCellJ, NCellK \\
                           & NBoundVertexI $= 0$, NBoundVertexJ $= 0$, \\
                           & NBoundVertexK \\[0.75\baselineskip]
         2D structured     & NVertexI, NVertexJ \\
                           & NCellI, NCellJ \\
                           & NBoundVertexI $= 0$, NBoundVertexJ $= 0$ \\[0.75\baselineskip]
         3D unstructured   & NVertex, NCell3D, NBoundVertex \\[0.75\baselineskip]
         2D unstructured   & NVertex, NCell2D, NBoundVertex
      \end{tabular}
      \setlength{\extrarowheight}{\tmplength}

      (\textcolor{input}{Input} for \texttt{cg\_zone\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_zone\_read})
\item [\texttt{zonetype}]
      Type of the zone.
      The admissible types are \texttt{Structured} and \texttt{Unstructured}.
      (\textcolor{input}{Input} for \texttt{cg\_zone\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_zone\_type})
\item [\texttt{index\_dim}]
      Index dimension for the zone. For Structured zones,
      this will be the base cell dimension and for Unstructured zones
      it will be 1.
      (\textcolor{output}{\textit{output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

Note that the zones are sorted alphanumerically to insure that
they can always be retrieved in the same order (for the same
model).
\emph{Therefore, users must name their zones alphanumerically to ensure
proper retrieval.}

\subsection{Simulation Type}
\label{s:simulationtype}

\noindent
\textit{Node}: \texttt{SimulationType\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_simulation\_type\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, & - w m \\
~~~~~~\textcolor{input}{SimulationType\_t SimulationType}); & \\
\textcolor{output}{\textit{ier}} = cg\_simulation\_type\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, & r - m \\
~~~~~~\textcolor{output}{\textit{SimulationType\_t SimulationType}}); & \\
\hline
call cg\_simulation\_type\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{SimulationType}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_simulation\_type\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{SimulationType}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\texttt{SimulationType}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{Input})
\item [\texttt{SimulationType}]
      Type of simulation.
      Valid types are \texttt{CG\_Null}, \texttt{CG\_UserDefined},
      \texttt{TimeAccurate}, and \texttt{NonTimeAccurate}.
      (\textcolor{input}{Input} for \texttt{cg\_simulation\_type\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_simulation\_type\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}
