\section{Auxiliary Data}
\label{s:auxiliary}
\thispagestyle{plain}

\subsection{Reference State}
\label{s:refstate}

\noindent
\textit{Node}: \texttt{ReferenceState\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_state\_write(\textcolor{input}{char *StateDescription}); & - w m \\
\textcolor{output}{\textit{ier}} = cg\_state\_read(\textcolor{output}{\textit{char **StateDescription}}); & r - m \\
\hline
call cg\_state\_write\_f(\textcolor{input}{StateDescription}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_state\_size\_f(\textcolor{output}{\textit{Size}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_state\_read\_f(\textcolor{output}{\textit{StateDescription}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode. 
See ``64-bit Fortran Portability and Issues" section.) 

\begin{Ventryi}{\texttt{StateDescription}}\raggedright
\item [\texttt{StateDescription}]
      Text description of reference state.
      (\textcolor{input}{Input} for \texttt{cg\_state\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_state\_read})
\item [\texttt{Size}]
      Number of characters in the \texttt{StateDescription} string
      (Fortran interface only).
      (\textcolor{output}{\textit{Output}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The function \texttt{cg\_state\_write} creates the
\texttt{ReferenceState\_t} node and must be called even if
\texttt{StateDescription} is undefined (i.e., a blank string).
The descriptors, data arrays, data class, and dimensional units
characterizing the \texttt{ReferenceState\_t} data structure may be added
to this data structure after its creation.

The function \texttt{cg\_state\_read} reads the \texttt{StateDescription}
of the local \texttt{ReferenceState\_t} node.
If \texttt{StateDescription} is undefined in the CGNS database, this
function returns a null string.
If \texttt{StateDescription} exists, the library will allocate the space
to store the description string, and return the description string to
the application.
It is the responsibility of the application to free this space when it
is no longer needed by a call to \texttt{cg\_free(StateDescription)},
described in \autoref{s:free}.

\subsection{Gravity}
\label{s:gravity}

\noindent
\textit{Node}: \texttt{Gravity\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_gravity\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{float *GravityVector}); & - w m \\
\textcolor{output}{\textit{ier}} = cg\_gravity\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{float *GravityVector}}); & r - m \\
\hline
call cg\_gravity\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{GravityVector}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_gravity\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{GravityVector}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{GravityVector}}\raggedright
\item [\texttt{fn}]
      CGNS file index number.
      (\textcolor{input}{\textit{Input}})
\item [\texttt{B}]
      Base index number, where $1 \leq \text{\texttt{B}} \leq \text{\texttt{nbases}}$.
      (\textcolor{input}{\textit{Input}})
\item [\texttt{GravityVector}]
      Components of the gravity vector.
      The number of components must equal \texttt{PhysicalDimension}.
      (In Fortran, this is an array of Real*4 values.)
      (\textcolor{input}{Input} for \texttt{cg\_gravity\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_gravity\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

\subsection{Convergence History}
\label{s:convergence}

\noindent
\textit{Node}: \texttt{ConvergenceHistory\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_convergence\_write(\textcolor{input}{int niterations}, \textcolor{input}{char *NormDefinitions}); & - w m \\
\textcolor{output}{\textit{ier}} = cg\_convergence\_read(\textcolor{output}{\textit{int *niterations}}, \textcolor{output}{\textit{char **NormDefinitions}}); & r - m \\
\hline
call cg\_convergence\_write\_f(\textcolor{input}{niterations}, \textcolor{input}{NormDefinitions}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_convergence\_read\_f(\textcolor{output}{\textit{niterations}}, \textcolor{output}{\textit{NormDefinitions}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{NormDefinitions}}\raggedright
\item [\texttt{niterations}]
      Number of iterations for which convergence information is recorded.
      (\textcolor{input}{Input} for \texttt{cg\_convergence\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_convergence\_read})
\item [\texttt{NormDefinitions}]
      Description of the convergence information recorded in the data arrays.
      (\textcolor{input}{Input} for \texttt{cg\_convergence\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_convergence\_read})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The function \texttt{cg\_convergence\_write} creates a
\texttt{ConvergenceHistory\_t} node.
It must be the first one called when recording convergence history data.
The \texttt{NormDefinitions} may be left undefined (i.e., a blank string).
After creation of this node, the descriptors, data arrays, data class,
and dimensional units characterizing the \texttt{ConvergenceHistory\_t}
data structure may be added.

The function \texttt{cg\_convergence\_read} reads a
\texttt{ConvergenceHistory\_t} node.
If \texttt{NormDefinitions} is not defined in the CGNS database, this
function returns a null string.
If \texttt{NormDefinitions} exists, the library will allocate the space
to store the description string, and return the description string to
the application.
It is the responsibility of the application to free this space when it
is no longer needed by a call to \texttt{cg\_free(NormDefinitions)},
described in \autoref{s:free}.

\subsection{Integral Data}
\label{s:integral}

\noindent
\textit{Node}: \texttt{IntegralData\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_integral\_write(\textcolor{input}{char *Name}); & - w m \\
\textcolor{output}{\textit{ier}} = cg\_nintegrals(\textcolor{output}{\textit{int *nintegrals}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_integral\_read(\textcolor{input}{int Index}, \textcolor{output}{\textit{char *Name}}); & r - m \\
\hline
call cg\_integral\_write\_f(\textcolor{input}{Name}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_nintegrals\_f(\textcolor{output}{\textit{nintegrals}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_integral\_read\_f(\textcolor{input}{Index}, \textcolor{output}{\textit{Name}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{nintegrals}}\raggedright
\item [\texttt{Name}]
      Name of the \texttt{IntegralData\_t} data structure.
      (\textcolor{input}{Input} for \texttt{cg\_integral\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_integral\_read})
\item [\texttt{nintegrals}]
      Number of \texttt{IntegralData\_t} nodes under current node.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{Index}]
      Integral data index number, where $1 \leq \text{\texttt{Index}} \leq \text{\texttt{nintegrals}}$.
      (\textcolor{input}{Input})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

\subsection{User-Defined Data}
\label{s:userdefined}

\noindent
\textit{Node}: \texttt{UserDefinedData\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_user\_data\_write(\textcolor{input}{char *Name}); & - w m \\
\textcolor{output}{\textit{ier}} = cg\_nuser\_data(\textcolor{output}{\textit{int *nuserdata}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_user\_data\_read(\textcolor{input}{int Index}, \textcolor{output}{\textit{char *Name}}); & r - m \\
\hline
call cg\_user\_data\_write\_f(\textcolor{input}{Name}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_nuser\_data\_f(\textcolor{output}{\textit{nuserdata}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_user\_data\_read\_f(\textcolor{input}{Index}, \textcolor{output}{\textit{Name}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)

\begin{Ventryi}{\texttt{nintegrals}}\raggedright
\item [\texttt{nuserdata}]
      Number of \texttt{UserDefinedData\_t} nodes under current node.
      (\textcolor{output}{\textit{Output}})
\item [\texttt{Name}]
      Name of the \texttt{UserDefinedData\_t} node.
      (\textcolor{input}{Input} for \texttt{cg\_user\_data\_write};
      \textcolor{output}{\textit{output}} for \texttt{cg\_user\_data\_read})
\item [\texttt{Index}]
      User-defined data index number, where $1 \leq \text{\texttt{Index}} \leq \text{\texttt{nuserdata}}$.
      (\textcolor{input}{Input})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

After accessing a particular \texttt{UserDefinedData\_t} node using
\texttt{cg\_goto}, the Point Set functions described in \autoref{s:ptset}
may be used to read or write point set information for the node.
The function \texttt{cg\_gridlocation\_write} may also be used to specify
the location of the data with respect to the grid (e.g., \texttt{Vertex}
or \texttt{FaceCenter}).

Multiple levels of \texttt{UserDefinedData\_t} nodes may be written and
retrieved by positioning via \texttt{cg\_goto}.
E.g.,
\begin{alltt}
   ier = cg\_goto(fn, B, "Zone\_t", Z, "UserDefinedData\_t", ud1, 
                 "UserDefinedData\_t", ud2, "UserDefinedData\_t", ud3, "end");
\end{alltt}

\subsection{Freeing Memory}
\label{s:free}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_free(\textcolor{input}{void *data}); & r w m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\noindent (Note that for Fortran calls, all integer arguments are integer*4 in 32-bit mode and integer*8 in 64-bit mode.
See ``64-bit Fortran Portability and Issues" section.)
\begin{Ventryi}{\texttt{nintegrals}}\raggedright
\item [\texttt{data}]
      Data allocated by the Mid-Level Library.
      (\textcolor{input}{\textit{Input}})
\item [\texttt{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

This function does not affect the structure of a CGNS file; it is
provided as a convenience to free memory allocated by the Mid-Level
Library when using C.
This isn't necessary in Fortran, and thus an equivalent Fortran function
is not provided.

The functions that are used to allocate memory for return values are
\texttt{cg\_descriptor\_read}, \texttt{cg\_convergence\_read},
\texttt{cg\_geo\_read}, \texttt{cg\_link\_read}, and
\texttt{cg\_state\_read}.
Each of these may allocate space to contain the data returned
to the application.
It is the responsibility of the application to free this data when it is
no longer needed.
Calling \texttt{cg\_free} is identical to calling the standard C function
\texttt{free}, however it is probably safer in that the memory is
freed in the same module in which it is created, particularly when the
Mid-Level Library is a shared library or DLL.
The routine checks for NULL data and will return \texttt{CG\_ERROR} in
this case, otherwise it returns \texttt{CG\_OK}.
