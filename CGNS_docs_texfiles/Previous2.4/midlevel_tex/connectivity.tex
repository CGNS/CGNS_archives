\section{Grid Connectivity}
\label{s:connectivity}
\thispagestyle{plain}

\subsection{One-to-One Connectivity}
\label{s:1to1}

\noindent
\textit{Node}: \fort{GridConnectivity1to1\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_n1to1\_global(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{int *n1to1\_global}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_read\_global(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{output}{\textit{char **connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{char **zonename}}, \textcolor{output}{\textit{char **donorname}}, \textcolor{output}{\textit{int **range}}, & \\
~~~~~~\textcolor{output}{\textit{int **donor\_range}}, \textcolor{output}{\textit{int **transform}}); & \\
\hline
call cg\_n1to1\_global\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{n1to1\_global}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_read\_global\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{zonename}}, \textcolor{output}{\textit{donorname}}, & r - m \\
~~~~~\textcolor{output}{\textit{range}}, \textcolor{output}{\textit{donor\_range}}, \textcolor{output}{\textit{transform}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\fort{n1to1\_global}}\raggedright
\item [\fort{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\fort{B}]
      Base index number, where $1 \leq \text{\fort{B}} \leq \text{\fort{nbases}}$.
      (\textcolor{input}{Input})
\item [\fort{n1to1\_global}]
      Total number of one-to-one interfaces in base \fort{B},
      stored under \fort{GridConnectivity1to1\_t} nodes.
      (I.e., this does not include one-to-one interfaces that may be
      stored under \fort{GridConnectivity\_t} nodes, used for
      generalized zone interfaces.)
      Note that the function \fort{cg\_n1to1} (described below) may be
      used to get the number of one-to-one interfaces in a specific
      zone.
      (\textcolor{output}{\textit{Output}})
\item [\fort{connectname}]
      Name of the interface.
      (\textcolor{output}{\textit{Output}})
\item [\fort{zonename}]
      Name of the first zone, for all one-to-one interfaces in base
      \fort{B}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{donorname}]
      Name of the second zone, for all one-to-one interfaces in base
      \fort{B}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{range}]
      Range of points for the first zone, for all one-to-one interfaces
      in base \fort{B}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{donor\_range}]
      Range of points for the current zone, for all one-to-one interfaces
      in base \fort{B}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{transform}]
      Short hand notation for the transformation matrix defining the
      relative orientation of the two zones.
      This transformation is given for all one-to-one interfaces in
      base \fort{B}.
      See the description of \fort{GridConnectivity1to1\_t} in the
      \href{../sids/sids.pdf}{SIDS manual} for details.
      (\textcolor{output}{\textit{Output}})
\item [\fort{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions may be used to get information about all the
one-to-one zone interfaces in a CGNS database.

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_1to1\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{char *donorname}, \textcolor{input}{int *range}, \textcolor{input}{int *donor\_range}, \textcolor{input}{int *transform}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_n1to1(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *n1to1}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{char *donorname}}, \textcolor{output}{\textit{int *range}}, \textcolor{output}{\textit{int *donor\_range}}, \textcolor{output}{\textit{int *transform}}); & \\
\hline
call cg\_1to1\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{donorname}, \textcolor{input}{range}, & - w m \\
~~~~~\textcolor{input}{donor\_range}, \textcolor{input}{transform}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_n1to1\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{n1to1}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{donorname}}, \textcolor{output}{\textit{range}}, & r - m \\
~~~~~\textcolor{output}{\textit{donor\_range}}, \textcolor{output}{\textit{transform}}, \textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\fort{connectname}}\raggedright
\item [\fort{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\fort{B}]
      Base index number, where $1 \leq \text{\fort{B}} \leq \text{\fort{nbases}}$.
      (\textcolor{input}{Input})
\item [\fort{Z}]
      Zone index number, where $1 \leq \text{\fort{Z}} \leq \text{\fort{nzones}}$.
      (\textcolor{input}{Input})
\item [\fort{I}]
      Interface index number, where $1 \leq \text{\fort{I}} \leq \text{\fort{n1to1}}$.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_read};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_write})
\item [\fort{n1to1}]
      Number of one-to-one interfaces in zone \fort{Z}, stored under
      \fort{GridConnectivity1to1\_t} nodes.
      (I.e., this does not include one-to-one interfaces that may be
      stored under \fort{GridConnectivity\_t} nodes, used for
      generalized zone interfaces.)
      (\textcolor{output}{\textit{Output}})
\item [\fort{connectname}]
      Name of the interface.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_read})
\item [\fort{donorname}]
      Name of the zone interfacing with the current zone.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_read})
\item [\fort{range}]
      Range of points for the current zone.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_read})
\item [\fort{donor\_range}]
      Range of points for the donor zone.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_read})
\item [\fort{transform}]
      Short hand notation for the transformation matrix defining the
      relative orientation of the two zones.
      See the description of \fort{GridConnectivity1to1\_t} in the
      \href{../sids/sids.pdf}{SIDS manual} for details.
      (\textcolor{input}{Input} for \fort{cg\_1to1\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_1to1\_read})
\item [\fort{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

The above functions are used to read and write one-to-one connectivity
data for a specific zone.

\newpage
\subsection{Generalized Connectivity}
\label{s:generalized}

\noindent
\textit{Node}: \fort{GridConnectivity\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_conn\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{GridConnectivityType\_t connect\_type}, & \\
~~~~~~\textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{input}{char *donorname}, & \\
~~~~~~\textcolor{input}{ZoneType\_t donor\_zonetype}, \textcolor{input}{PointSetType\_t donor\_ptset\_type}, & \\
~~~~~~\textcolor{input}{DataType\_t donor\_datatype}, \textcolor{input}{int ndata\_donor}, \textcolor{input}{void *donor\_data}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_write\_short(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *connectname}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{GridConnectivityType\_t connect\_type}, & \\
~~~~~~\textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{input}{char *donorname}, & \\
~~~~~~\textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nconns(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nconns}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_conn\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *connectname}}, & r - m \\
~~~~~~\textcolor{output}{\textit{GridLocation\_t *location}}, \textcolor{output}{\textit{GridConnectivityType\_t *connect\_type}}, & \\
~~~~~~\textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, \textcolor{output}{\textit{int *npnts}}, \textcolor{output}{\textit{char *donorname}}, & \\
~~~~~~\textcolor{output}{\textit{ZoneType\_t *donor\_zonetype}}, \textcolor{output}{\textit{PointSetType\_t *donor\_ptset\_type}}, & \\
~~~~~~\textcolor{output}{\textit{DataType\_t *donor\_datatype}}, \textcolor{output}{\textit{int *ndata\_donor}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{int *pnts}}, & r - m \\
~~~~~~\textcolor{input}{DataType\_t donor\_datatype}, \textcolor{output}{\textit{void *donor\_data}}); & \\
\hline
call cg\_conn\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{location}, \textcolor{input}{connect\_type}, & - w m \\
~~~~~\textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{input}{donorname}, \textcolor{input}{donor\_zonetype}, & \\
~~~~~\textcolor{input}{donor\_ptset\_type}, \textcolor{input}{donor\_datatype}, \textcolor{input}{ndata\_donor}, \textcolor{input}{donor\_data}, \textcolor{output}{\textit{I}}, & \\
~~~~~\textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_write\_short\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{connectname}, \textcolor{input}{location}, & - w m \\
~~~~~\textcolor{input}{connect\_type}, \textcolor{input}{ptset\_type}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{input}{donorname}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_nconns\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nconns}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_conn\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{connectname}}, \textcolor{output}{\textit{location}}, \textcolor{output}{\textit{connect\_type}}, & r - m \\
~~~~~\textcolor{output}{\textit{ptset\_type}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{donorname}}, \textcolor{output}{\textit{donor\_zonetype}}, \textcolor{output}{\textit{donor\_ptset\_type}}, & \\
~~~~~\textcolor{output}{\textit{donor\_datatype}}, \textcolor{output}{\textit{ndata\_donor}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{pnts}}, \textcolor{input}{donor\_datatype}, \textcolor{output}{\textit{donor\_data}}, & r - m \\
~~~~~\textcolor{output}{\textit{ier}}) & \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\fort{donor\_ptset\_type}}\raggedright
\item [\fort{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\fort{B}]
      Base index number, where $1 \leq \text{\fort{B}} \leq \text{\fort{nbases}}$.
      (\textcolor{input}{Input})
\item [\fort{Z}]
      Zone index number, where $1 \leq \text{\fort{Z}} \leq \text{\fort{nzones}}$.
      (\textcolor{input}{Input})
\item [\fort{I}]
      Discrete data index number, where $1 \leq \text{\fort{I}} \leq \text{\fort{nconns}}$.
      (\textcolor{input}{Input} for \fort{cg\_conn\_info},
      \fort{cg\_conn\_read};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short})
\item [\fort{nconns}]
      Number of interfaces for zone \fort{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{connectname}]
      Name of the interface.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{location}]
      Grid location used in the definition of the point set.
      The currently admissible locations are \fort{Vertex} and
      \fort{CellCenter}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{connect\_type}]
      Type of interface being defined.
      The admissible types are \fort{Overset}, \fort{Abutting},
      and \fort{Abutting1to1}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{ptset\_type}]
      Type of point set defining the interface in the current zone;
      either \fort{PointRange} or \fort{PointList}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{donor\_ptset\_type}]
      Type of point set defining the interface in the donor zone;
      either \fort{PointListDonor} or \fort{CellListDonor}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{npnts}]
      Number of points defining the interface in the current zone.
      For a \fort{ptset\_type} of \fort{PointRange}, \fort{npnts}
      is always two.
      For a \fort{ptset\_type} of \fort{PointList}, \fort{npnts} is
      the number of points in the \fort{PointList}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{ndata\_donor}]
      Number of points or cells in the current zone.
      These are paired with points, cells, or fractions thereof in the
      donor zone.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{donorname}]
      Name of the zone interfacing with the current zone.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{donor\_datatype}]
      Data type in which the donor points are stored in the file.
      The only admissible type, as of version 2.0 of the Mid-Level
      Library, is \fort{Integer}.
      The \fort{donor\_datatype} argument was left in these functions
      only for backward compatibility.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_read};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{pnts}]
      Array of points defining the interface in the current zone.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write},
      \fort{cg\_conn\_write\_short};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_read})
\item [\fort{donor\_data}]
      Array of donor points or cells corresponding to
      \texttt{ndata\_donor}.
      Note that it is possible that the same donor point or cell may
      be used multiple times.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_read})
\item [\fort{donor\_zonetype}]
      Type of the donor zone.
      The admissible types are \fort{Structured} and \fort{Unstructured}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_info})
\item [\fort{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

Note that the interpolation factors stored
in the \fort{InterpolantsDonor} data array are accessed using the
\fort{cg\_goto} and \fort{cg\_array\_\textit{xxx}} functions, described
in \autoref{s:navigating} and \autoref{s:dataarray}, respectively.

\newpage
\subsection{Special Grid Connectivity Properties}
\label{s:connproperty}

\noindent
\textit{Node}: \fort{GridConnectivityProperty\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_conn\_periodic\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{float *RotationCenter}, \textcolor{input}{float *RotationAngle}, \textcolor{input}{float *Translation}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_average\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{AverageInterfaceType\_t AverageInterfaceType}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_periodic\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{float *RotationCenter}, \textcolor{input}{float *RotationAngle}, \textcolor{input}{float *Translation}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_average\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & - w m \\
~~~~~~\textcolor{input}{AverageInterfaceType\_t AverageInterfaceType}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_periodic\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{float *RotationCenter}}, \textcolor{output}{\textit{float *RotationAngle}}, & \\
~~~~~~\textcolor{output}{\textit{float *Translation}}); & \\
\textcolor{output}{\textit{ier}} = cg\_conn\_average\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{AverageInterfaceType\_t *AverageInterfaceType}}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_periodic\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{float *RotationCenter}}, \textcolor{output}{\textit{float *RotationAngle}}, & \\
~~~~~~\textcolor{output}{\textit{float *Translation}}); & \\
\textcolor{output}{\textit{ier}} = cg\_1to1\_average\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, & r - m \\
~~~~~~\textcolor{output}{\textit{AverageInterfaceType\_t *AverageInterfaceType}}); & \\
\hline
call cg\_conn\_periodic\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{RotationCenter}, & - w m \\
~~~~~\textcolor{input}{RotationAngle}, \textcolor{input}{Translation}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_average\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{AverageInterfaceType}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_1to1\_periodic\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{RotationCenter}, & - w m \\
~~~~~\textcolor{input}{RotationAngle}, \textcolor{input}{Translation}, \textcolor{output}{\textit{ier}}) & \\
call cg\_1to1\_average\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{input}{AverageInterfaceType}, \textcolor{output}{\textit{ier}}) & - w m \\
call cg\_conn\_periodic\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{RotationCenter}}, & r - m \\
~~~~~\textcolor{output}{\textit{RotationAngle}}, \textcolor{output}{\textit{Translation}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_conn\_average\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{AverageInterfaceType}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_1to1\_periodic\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{RotationCenter}}, & r - m \\
~~~~~\textcolor{output}{\textit{RotationAngle}}, \textcolor{output}{\textit{Translation}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_1to1\_average\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{AverageInterfaceType}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\fort{AverageInterfaceType}}\raggedright
\item [\fort{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\fort{B}]
      Base index number, where $1 \leq \text{\fort{B}} \leq \text{\fort{nbases}}$.
      (\textcolor{input}{Input})
\item [\fort{Z}]
      Zone index number, where $1 \leq \text{\fort{Z}} \leq \text{\fort{nzones}}$.
      (\textcolor{input}{Input})
\item [\fort{I}]
      Grid connectivity index number, where
      $1 \leq \text{\fort{I}} \leq \text{\fort{nconns}}$
      for the ``\fort{cg\_conn}'' functions, and
      $1 \leq \text{\fort{I}} \leq \text{\fort{n1to1}}$
      for the ``\fort{cg\_1to1}'' functions.
      (\textcolor{input}{Input})
\item [\fort{RotationCenter}]
      An array of size \fort{phys\_dim} defining the coordinates of
      the origin for defining the rotation angle between the periodic
      interfaces.
      (\fort{phys\_dim} is the number of coordinates required to define
      a vector in the field.)
      (\textcolor{input}{Input} for \fort{cg\_conn\_periodic\_write},
      \fort{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_periodic\_read},
      \fort{cg\_1to1\_periodic\_read})
\item [\fort{RotationAngle}]
      An array of size \fort{phys\_dim} defining the rotation angle from
      the current interface to the connecting interface.
      (\textcolor{input}{Input} for \fort{cg\_conn\_periodic\_write},
      \fort{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_periodic\_read},
      \fort{cg\_1to1\_periodic\_read})
\item [\fort{Translation}]
      An array of size \fort{phys\_dim} defining the translation from
      the current interface to the connecting interface.
      (\textcolor{input}{Input} for \fort{cg\_conn\_periodic\_write},
      \fort{cg\_1to1\_periodic\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_periodic\_read},
      \fort{cg\_1to1\_periodic\_read})
\item [\fort{AverageInterfaceType}]
      The type of averaging to be done.
      Valid types are \fort{Null}, \fort{UserDefined}, \fort{AverageAll},
      \fort{AverageCircumferential}, \fort{AverageRadial}, \fort{AverageI},
      \fort{AverageJ}, and \fort{AverageK}.
      (\textcolor{input}{Input} for \fort{cg\_conn\_average\_write},
      \fort{cg\_1to1\_average\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_conn\_average\_read},
      \fort{cg\_1to1\_average\_read})
\item [\fort{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}

These functions may be used to store special grid connectivity properties.
The ``\fort{cg\_conn}'' functions apply to generalized grid
connectivity nodes (i.e., \fort{GridConnectivity\_t}), and the
``\fort{cg\_1to1}'' functions apply to 1-to-1 grid connectivity nodes
(i.e., \fort{GridConnectivity1to1\_t}).

The ``\fort{write}'' functions will create the
\fort{GridConnectivityProperty\_t} node if it doesn't already exist,
then add the appropriate connectivity property.
Multiple connectivity properties may be recorded under the same
\fort{GridConnectivityProperty\_t} node.

The ``\fort{read}'' functions will return with $\text{\fort{ier}} = 2 =
\text{\fort{CG\_NODE\_NOT\_FOUND}}$ if the requested connectivity property,
or the \fort{GridConnectivityProperty\_t} node itself, doesn't exist.

\newpage
\subsection{Overset Holes}
\label{s:overset}

\noindent
\textit{Node}: \fort{OversetHoles\_t}

\begin{fctbox}
\textcolor{output}{\textit{ier}} = cg\_hole\_write(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{char *holename}, & - w m \\
~~~~~~\textcolor{input}{GridLocation\_t location}, \textcolor{input}{PointSetType\_t ptset\_type}, \textcolor{input}{int nptsets}, & \\
~~~~~~\textcolor{input}{int npnts}, \textcolor{input}{int *pnts}, \textcolor{output}{\textit{int *I}}); & \\
\textcolor{output}{\textit{ier}} = cg\_nholes(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{output}{\textit{int *nholes}}); & r - m \\
\textcolor{output}{\textit{ier}} = cg\_hole\_info(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{char *holename}}, & r - m \\
~~~~~~\textcolor{output}{\textit{GridLocation\_t *location}}, \textcolor{output}{\textit{PointSetType\_t *ptset\_type}}, & \\
~~~~~~\textcolor{output}{\textit{int *nptsets}}, \textcolor{output}{\textit{int *npnts}}); & \\
\textcolor{output}{\textit{ier}} = cg\_hole\_read(\textcolor{input}{int fn}, \textcolor{input}{int B}, \textcolor{input}{int Z}, \textcolor{input}{int I}, \textcolor{output}{\textit{int *pnts}}); & r - m \\
\hline
call cg\_hole\_write\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{holename}, \textcolor{input}{location}, \textcolor{input}{ptset\_type}, & - w m \\
~~~~~\textcolor{input}{nptsets}, \textcolor{input}{npnts}, \textcolor{input}{pnts}, \textcolor{output}{\textit{I}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_nholes\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{output}{\textit{nholes}}, \textcolor{output}{\textit{ier}}) & r - m \\
call cg\_hole\_info\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{holename}}, \textcolor{output}{\textit{location}}, \textcolor{output}{\textit{ptset\_type}}, & r - m \\
~~~~~\textcolor{output}{\textit{nptsets}}, \textcolor{output}{\textit{npnts}}, \textcolor{output}{\textit{ier}}) & \\
call cg\_hole\_read\_f(\textcolor{input}{fn}, \textcolor{input}{B}, \textcolor{input}{Z}, \textcolor{input}{I}, \textcolor{output}{\textit{pnts}}, \textcolor{output}{\textit{ier}}) & r - m \\
\end{fctbox}

\noindent
\textbf{\textcolor{input}{Input}/\textcolor{output}{\textit{Output}}}

\begin{Ventryi}{\fort{ptset\_type}}\raggedright
\item [\fort{fn}]
      CGNS file index number.
      (\textcolor{input}{Input})
\item [\fort{B}]
      Base index number, where $1 \leq \text{\fort{B}} \leq \text{\fort{nbases}}$.
      (\textcolor{input}{Input})
\item [\fort{Z}]
      Zone index number, where $1 \leq \text{\fort{Z}} \leq \text{\fort{nzones}}$.
      (\textcolor{input}{Input})
\item [\fort{I}]
      Overset hole index number, where $1 \leq \text{\fort{I}} \leq \text{\fort{nholes}}$.
      (\textcolor{input}{Input} for \fort{cg\_hole\_info},
      \fort{cg\_hole\_read};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_write})
\item [\fort{nholes}]
      Number of overset holes in zone \fort{Z}.
      (\textcolor{output}{\textit{Output}})
\item [\fort{holename}]
      Name of the overset hole.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_info})
\item [\fort{location}]
      Grid location used in the definition of the point set.
      The currently admissible locations are \fort{Vertex} and
      \fort{CellCenter}.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_info})
\item [\fort{ptset\_type}]
      The extent of the overset hole may be defined using a range of
      points or cells, or using a discrete list of all points or cells
      in the overset hole.
      If a range of points or cells is used, \fort{ptset\_type} is set
      to \fort{PointRange}.
      When a discrete list of points or cells is used,
      \fort{ptset\_type} equals \fort{PointList}.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_info})
\item [\fort{nptsets}]
      Number of point sets used to define the hole.
      If \fort{ptset\_type} is \fort{PointRange}, several point sets
      may be used.
      If \fort{ptset\_type} is \fort{PointList}, only one point set
      is allowed.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_info})
\item [\fort{npnts}]
      Number of points (or cells) in the point set.
      For a \fort{ptset\_type} of \fort{PointRange}, \fort{npnts}
      is always two.
      For a \fort{ptset\_type} of \fort{PointList}, \fort{npnts} is
      the number of points or cells in the \fort{PointList}.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_info})
\item [\fort{pnts}]
      Array of points or cells in the point set.
      (\textcolor{input}{Input} for \fort{cg\_hole\_write};
      \textcolor{output}{\textit{output}} for \fort{cg\_hole\_read})
\item [\fort{ier}]
      Error status.
      (\textcolor{output}{\textit{Output}})
\end{Ventryi}
