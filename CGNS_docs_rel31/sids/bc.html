<!-- CGNS SIDS document - Boundary Conditions -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<link href="sids.css" rel="stylesheet" type="text/css">
<title> CGNS Standard Interface Data Structures - Boundary Conditions </title>
</head>

<body text="#000000" bgcolor="#FFFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<a href="#endnav"><img src="../blank.gif" border=0 alt="Skip navigation links"></a>
<small>
<center>
(<a href="../index.html"><b>CGNS&nbsp;Documentation&nbsp;Home&nbsp;Page</b></a>)
(<a href="../charter/index.html"><b>Steering&nbsp;Committee&nbsp;Charter</b></a>)
(<a href="../overview/index.html"><b>Overview&nbsp;and&nbsp;Entry-Level&nbsp;Document</b></a>)
(<a href="../user/index.html"><b>A&nbsp;User's&nbsp;Guide&nbsp;to&nbsp;CGNS</b></a>)
(<a href="../midlevel/index.html"><b>Mid-Level&nbsp;Library</b></a>)
(<a href="index.html"><span class=nav><b>Standard&nbsp;Interface&nbsp;Data&nbsp;Structures</b></span></a>)
(<a href="../filemap/index.html"><b>SIDS&nbsp;File&nbsp;Mapping&nbsp;Manual</b></a>)
(<a href="../cgio/index.html"><b>CGIO&nbsp;User's&nbsp;Guide</b></a>)
(<a href="../adf/index.html"><b>ADF&nbsp;Implementation</b></a>)
(<a href="../hdf5/index.html"><b>HDF5&nbsp;Implementation</b></a>)
(<a href="../python/index.html"><b>Python&nbsp;Implementation</b></a>)
(<a href="../cgnstools/index.html"><b>CGNS&nbsp;Tools&nbsp;and&nbsp;Utilities</b></a>)
<br><br>
(<a href="intro.html"><b>Introduction</b></a>)
(<a href="design.html"><b>Design&nbsp;Philosophy&nbsp;of&nbsp;Standard&nbsp;Interface&nbsp;Data&nbsp;Structures</b></a>)
(<a href="conv.html"><b>Conventions</b></a>)
(<a href="build.html"><b>Building-Block&nbsp;Structure&nbsp;Definitions</b></a>)
(<a href="data.html"><b>Data-Array&nbsp;Structure&nbsp;Definitions</b></a>)
(<a href="cgnsbase.html"><b>Hierarchical&nbsp;Structures</b></a>)
(<a href="gridflow.html"><b>Grid&nbsp;Coordinates,&nbsp;Elements,&nbsp;and&nbsp;Flow&nbsp;Solution</b></a>)
(<a href="cnct.html"><b>Multizone&nbsp;Interface&nbsp;Connectivity</b></a>)
(<span class=nav><b>Boundary&nbsp;Conditions</b></span>)
(<a href="floweqn.html"><b>Governing&nbsp;Flow&nbsp;Equations</b></a>)
(<a href="timedep.html"><b>Time-Dependent&nbsp;Flow</b></a>)
(<a href="misc.html"><b>Miscellaneous&nbsp;Data&nbsp;Structures</b></a>)
(<a href="dataname.html"><b>Conventions&nbsp;for&nbsp;Data-Name&nbsp;Identifiers</b></a>)
(<a href="twozone.html"><b>Structured&nbsp;Two-Zone&nbsp;Flat&nbsp;Plate&nbsp;Example</b></a>)
</center>
</small>
<a name="endnav"></a>

<h2>Boundary Conditions</h2>

<ul>
<li> <a href="#BCstruct">Boundary Condition Structures Overview</a>
<li> <a href="#ZoneBC">Zonal Boundary Condition Structure Definition: <tt>ZoneBC_t</tt></a>
<li> <a href="#BC">Boundary Condition Structure Definition: <tt>BC_t</tt></a>
<li> <a href="#BCDataSet">Boundary Condition Data Set Structure Definition: <tt>BCDataSet_t</tt></a>
<li> <a href="#BCData">Boundary Condition Data Structure Definition: <tt>BCData_t</tt></a>
<li> <a href="#BCProperty">Boundary Condition Property Structure Definition: <tt>BCProperty_t</tt></a>
     <ul>
     <li> <a href="#WallFunction">Wall Function Structure Definition: <tt>WallFunction_t</tt></a>
     <li> <a href="#Area">Area Structure Definition: <tt>Area_t</tt></a>
     </ul>
<li> <a href="#BCType">Boundary Condition Type Structure Definition: <tt>BCType_t</tt></a>
<li> <a href="#BCType_assoc">Matching Boundary Condition Data Sets</a>
<li> <a href="#BC_specdata">Boundary Condition Specification Data</a>
<li> <a href="#BCexample">Boundary Condition Examples</a>
</ul>

<p>
This section is an attempt to unify boundary-condition specifications
within Navier-Stokes codes.
The structures and conventions developed are a compromise between
simplicity and generality.
It is imperative that they be easy to use initially, but that they are
general enough to provide future flexibility and extensibility.

<p>
This section may be somewhat daunting initially.
It is suggested that the reader refer to the
<a href="#BCexample">Boundary Condition Examples</a> during study of
the following sections to help resolve any questions and confusions
that might arise.

<p>
The difficulty with boundary conditions is that there is such a wide
variety used, and even a single boundary-condition equation is often
implemented differently in different codes.
Some boundary conditions, such as a symmetry plane, are fairly well
defined.
Other boundary conditions are much looser in their definition and
implementation.
An inflow boundary is a good example.
It is generally accepted how many solution quantities should be
specified at an inflow boundary (from mathematical well-posedness
arguments), but what those quantities are will change with the class of
flow problems (e.g., internal flows vs. external flows), and they will
also change from code to code.

<p>
An additional difficulty for CFD analysis is that in some situations
different boundary-condition equations are applied depending on local
flow conditions.
Any boundary where the flow can change from inflow to outflow
or supersonic to subsonic is a candidate for flow-dependent
boundary-condition equations.

<p>
These difficulties have molded the design of our boundary-condition
specification structures and conventions.
We define <a href="#BCType">boundary-condition types</a> that establish
the equations to be enforced.
However, for those more loosely defined boundary conditions, such as
inflow/outflow, the boundary-condition type merely establishes general
guidelines on the equations to be imposed.
Augmenting (and superseding) the information provided by the
boundary-condition type is precisely defined boundary-condition
solution data.
We rely on our <a href="dataname.html">conventions for data-name
identifiers</a> to identify the exact quantities involved in the
boundary conditions.

<p>
One flexibility that is provided by this approach is that
boundary-condition information can easily be built during the course of
an analysis.
For example, during grid-generation phases minimal information (e.g., the
boundary-condition type) may be given.
Then prior to running of the flow solver, more specific
boundary-condition information, such as Dirichlet or Neumann data, may
be added to the database.

<p>
An additional flexibility provided by the structures of this section
is that both uniform and non-uniform boundary-condition data can be
described within the same framework.

<p>
We realize that most current codes allow little or no flexibility in
choosing solution quantities to specify for a given boundary-condition
type.
We also realize the coding effort involved with checking for consistency
between I/O specifications and internal boundary-condition routines.
To make these boundary-condition structures more palatable initially, we
adopt the convention that if no solution quantities are specified for
a given boundary-condition type, then the code is free to enforce any
appropriate boundary condition
(see <a href="#BC_specdata">Boundary Condition Specification Data</a>).

<p>
Note that there are no boundary-condition structures defined for
abutting or overset interfaces, unless they involve cases of symmetry or
degeneracy.
In other words, it is a CGNS design intent that a given zone boundary
segment or location should at most be defined (or covered) by either a
boundary condition or a multizone interface connectivity, but not by
both.
There is also no separate boundary-condition structure for periodic
boundary conditions (i.e., when a zone interfaces with itself).
Both of these situations are addressed by <a href="cnct.html">interface
connectivity data structures</a>.

<p>
In the sections to follow, the definitions of boundary-condition
structures are presented in the first six sections.
<a href="#BCType">Boundary-condition types</a> are then discussed in
detail, including a description of the boundary-condition
equations to be enforced for each type; this section also describes
the distinction between boundary-condition types that impose a set of
equations regardless of local flow conditions and those that impose
different sets of boundary-condition equations depending on the local
flow solution.
The rules for <a href="#BCType_assoc">matching boundary-condition types
and the appropriate sets of boundary-condition equations</a> are next
discussed.
Details of <a href="#BC_specdata">specifying data to be imposed in
boundary-condition equations</a> are provided next.
Finally, several <a href="#BCexample">examples of boundary
conditions</a> are presented.

<a name="BCstruct"></a>
<h3>Boundary Condition Structures Overview</h3>

<p>
Prior to presenting the detailed boundary condition structures, we give
a brief overview of the hierarchy used to describe boundary conditions.

<p>
Boundary conditions are classified as either fixed or flow-dependent.
Fixed boundary conditions enforce a given set of boundary-condition
equations regardless of flow conditions; whereas, flow-dependent
boundary conditions enforce different sets of boundary-condition
equations depending on local flow conditions.
We incorporate both fixed and flow-dependent boundary conditions into a
uniform framework.
This allows all boundary conditions to be described in a similar manner.
We consider this functionally superior to separately treating fixed
and flow-dependent boundary conditions, even though the latter allows a
simpler description mechanism for fixed boundary conditions.
The current organization also makes sense considering the fact that
flow-dependent boundary conditions are composed of multiple sets of
fixed boundary conditions.

<a name="f:bctree"></a>
<br><br>
<center>
<img src="bc.figs/bctree.gif"
     alt="CGNS hierarchy for a single boundary condition"
     longdesc="bc.figs/bctree.html">
<br><br>
Hierarchy for Boundary Condition Structures
</center>

<p>
The above figure depicts the hierarchy used for prescribing a single
boundary condition.
Each boundary condition includes a type that describes the general
equations to enforce, a patch specification, and a collection of data
sets.
The minimum required information for any boundary condition is the patch
specification and the boundary-condition type (indicated by "BC type
(compound)" in the figure).
This minimum information is similar to that used in many existing flow
solvers.

<p>
Generality in prescribing equations to enforce and their associated
boundary-condition data is provided in the optional data sets.
Each data set contains all boundary condition data required for a given
fixed or simple boundary condition.
Each data set is also tagged with a boundary-condition type.
For fixed boundary conditions, the hierarchical tree contains a
single data set, and the two boundary-condition types shown in
the above figure are identical.
Flow-dependent or compound boundary conditions contain multiple data
sets, each to be applied separately depending on local flow conditions.
The compound boundary-condition type describes the general
flow-dependent boundary conditions, and each data set contains
associated simple boundary-condition types.
For example, a farfield boundary condition would contain four data
sets, where each applies to the different combinations of subsonic and
supersonic inflow and outflow.
See the sections <a href="#BCType">Boundary Condition Type Structure
Definition: <tt>BCType_t</tt></a> and 
<a href="#BCType_assoc">Matching Boundary Condition Data Sets</a> for
more details.

<p>
Within a single data set, boundary condition data is grouped by equation
type into Dirichlet and Neumann data.
The lower leaves of the above figure show data for generic
flow-solution quantities
<i>&alpha;</i> and <i>&beta;</i> to be applied in Dirichlet conditions,
and data for <i>&gamma;</i> and <i>&delta;</i> to be applied in
Neumann boundary conditions.
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> entities are
employed to store these data and to identify the specific flow variables
they are associated with.

<p>
In situations where the data sets (or any information contained therein)
are absent from a given boundary-condition hierarchy, flow solvers are
free to impose any appropriate boundary conditions.
Although not pictured in the above figure, it is also possible to
specify the reference state from which the flow solver should extract
the boundary-condition data.

<a name="ZoneBC"></a>
<h3>Zonal Boundary Condition Structure Definition: <tt>ZoneBC_t</tt></h3>

<p>
All boundary-condition information pertaining to a given zone is
contained in the <tt>ZoneBC_t</tt> structure.
<pre>
  ZoneBC_t&lt; int CellDimension, int IndexDimension, int PhysicalDimension &gt; :=
    {
    List( Descriptor_t Descriptor1 ... DescriptorN ) ;                 (o)

    List( BC_t&lt;CellDimension, IndexDimension, int PhysicalDimension&gt;
          BC1 ... BCN ) ;                                              (o)

    ReferenceState_t ReferenceState ;                                  (o)

    DataClass_t DataClass ;                                            (o)
                
    DimensionalUnits_t DimensionalUnits ;                              (o)

    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a>,
     <a href="#BC"><tt>BC_t</tt></a>, and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance
     of <tt>ZoneBC_t</tt> and shall not include the names
     <tt>DataClass</tt>, <tt>DimensionalUnits</tt>, or
     <tt>ReferenceState</tt>.
<li> All lists within a <tt>ZoneBC_t</tt> structure entity may be empty.
</ol>

<p>
<tt>ZoneBC_t</tt> requires three structure parameters, <tt>CellDimension</tt>,
<tt>IndexDimension</tt> and <tt>PhysicalDimension</tt>, which are passed
onto all <a href="#BC"><tt>BC_t</tt></a> substructures.

<p>
Boundary-condition information for a single patch is contained in the
<a href="#BC"><tt>BC_t</tt></a> structure.
All boundary-condition information pertaining to a given zone is
contained in the list of <tt>BC_t</tt> structure entities.
If a zone contains <i>N</i> boundary-condition patches, then <i>N</i>
(and only <i>N</i>) separate instances of <tt>BC_t</tt> must be provided
in the <tt>ZoneBC_t</tt> entity for the zone.
That is, each boundary-condition patch must be represented by a single
<tt>BC_t</tt> entity.

<p>
Reference data applicable to all boundary conditions of a zone is
contained in the <a href="misc.html#ReferenceState"><tt>ReferenceState</tt></a>
structure.
<a href="build.html#DataClass"><tt>DataClass</tt></a> defines the zonal
default for the class of data contained in the boundary conditions of a
zone.
If the boundary conditions contain dimensional data,
<a href="build.html#DimensionalUnits"><tt>DimensionalUnits</tt></a>
may be used to describe the system of dimensional units employed.
If present, these three entities take precedence of all corresponding
entities at higher levels of the hierarchy, following the standard
<a href="cgnsbase.html#precedence">precedence rules</a>.

<p>
Reference-state data is useful for situations where boundary-condition
data is not provided, and flow solvers are free to enforce any
appropriate boundary condition equations.
The presense of <a href="misc.html#ReferenceState"><tt>ReferenceState</tt></a>
at this level or below specifies the appropriate flow conditions from
which the flow solver should extract its boundary-condition data.
For example, when computing an external flowfield around an airplane, an
engine nozzle exit is often simulated by imposing a stagnation pressure
boundary condition (or some other stagnation quantity) different from
freestream.
The nozzle-exit stagnation quantities could be specified in an instance
of <tt>ReferenceState</tt> at this level or below in lieu of providing
explicit Dirichlet or Neumann data.
(See <a href="#BC_specdata">Boundary Condition Specification Data</a>.)

<p>
The <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
data structure allows arbitrary user-defined data to be stored in
<tt>Descriptor_t</tt> and <tt>DataArray_t</tt> children without the
restrictions or implicit meanings imposed on these node types at other
node locations.

<a name="BC"></a>
<h3>Boundary Condition Structure Definition: <tt>BC_t</tt></h3>

<p>
<tt>BC_t</tt> contains boundary-condition information for a single BC surface
patch of a zone.
A BC patch is the subrange of the face of a zone where a given boundary
condition is applied.

<p>
The structure contains a boundary-condition type, as well as one or
more sets of boundary-condition data that are used to define the
boundary-condition equations to be enforced on the BC patch.
For most boundary conditions, a single data set is all that is needed.
The structure also contains information describing the normal vector to
the BC surface patch.

<pre>
  BC_t&lt; int CellDimension, int IndexDimension, int PhysicalDimension &gt; :=
    {
    List( Descriptor_t Descriptor1 ... DescriptorN ) ;                 (o)

    BCType_t BCType ;                                                  (r)

    GridLocation_t GridLocation ;                                      (o/d)

    IndexRange_t&lt;IndexDimension&gt; PointRange ;                          (r:o)
    IndexArray_t&lt;IndexDimension, ListLength[], int&gt; PointList ;        (o:r)

    int[IndexDimension] InwardNormalIndex ;                            (o)

    IndexArray_t&lt;PhysicalDimension, ListLength[], real&gt;
       InwardNormalList ;                                              (o)

    List( BCDataSet_t&lt;CellDimension, IndexDimension, ListLength[], GridLocation&gt;
          BCDataSet1 ... BCDataSetN ) ;                                (o)

    BCProperty_t BCProperty ;                                          (o)

    FamilyName_t FamilyName ;                                          (o)

    ReferenceState_t ReferenceState ;                                  (o)

    DataClass_t DataClass ;                                            (o)
                
    DimensionalUnits_t DimensionalUnits ;                              (o)

    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)

    int Ordinal ;                                                      (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a>,
     <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>, and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance of
     <tt>BC_t</tt> and shall not include the names <tt>BCProperty</tt>,
     <tt>BCType</tt>, <tt>DataClass</tt>, <tt>DimensionalUnits</tt>,
     <tt>FamilyName</tt>, <tt>GridLocation</tt>, <tt>InwardNormalIndex</tt>,
     <tt>InwardNormalList</tt>, <tt>Ordinal</tt>, <tt>PointList</tt>,
     <tt>PointRange</tt>, or <tt>ReferenceState</tt>.
<li> <a href="build.html#GridLocation"><tt>GridLocation</tt></a> is optional;
     if absent its default value is <tt>Vertex</tt>. For other allowble
     values, see the table below.
<li> One of <tt>PointRange</tt> or <tt>PointList</tt> must be specified but not
     both. They must define a subrange of the zone.
<li> <tt>InwardNormalIndex</tt> is only an option for structured grids.
     For unstructured grid boundaries, it should not be used.
     <tt>InwardNormalIndex</tt> may have only one nonzero element, whose
     sign indicates the computational-coordinate direction of the BC
     patch normal; this normal points into the interior of the zone.
<li> <tt>InwardNormalList</tt> contains a list of vectors normal to the
     BC patch pointing into the interior of the zone.
     It is a function of <tt>PhysicalDimension</tt> and
     <a href="#ListLength"><tt>ListLength[]</tt></a>.
     The vectors are located at the vertices of the BC patch when
     <a href="build.html#GridLocation"><tt>GridLocation</tt></a> is set
     to <tt>Vertex</tt>. Otherwise, they are located at edge/face midpoints.
     The vectors are not required to have unit magnitude.
<li> If <tt>PointRange</tt> and <tt>InwardNormalList</tt> are specified,
     an ordering  convention is needed for indices on the BC patch.
     An ordering convention is also needed if a range is specified and
     local data is present in the
     <a href="#BCDataSet"><tt>BCDataSet_t</tt></a> substructures.
     FORTRAN multidimensional array ordering is used.
</ol>

<p>
<a href="#BCType"><tt>BCType</tt></a> specifies the boundary-condition
type, which gives general information on the boundary-condition
equations to be enforced.

<p>
The BC patch may be specified by <tt>PointRange</tt> if it constitutes a
logically rectangular region. In all other cases, <tt>PointList</tt> should be
used to list the vertices or cell edges/faces making up the BC patch.
When <tt>GridLocation</tt> is set to <tt>Vertex</tt>, then <tt>PointList</tt>
or <tt>PointRange</tt> refer to vertex indices, for both structured and
unstructured grids. When <tt>GridLocation</tt> is set to <tt>EdgeCenter</tt>,
then <tt>PointRange/List</tt> refer to edge elements. For 3-D grids, when
<tt>GridLocation</tt> is set to <tt>FaceCenter</tt>, <tt>IFaceCenter</tt>, etc.,
then <tt>PointRange/List</tt> refer to face elements. The interpretation of
<tt>PointRange/List</tt> is summarized in the table below:

<center>
<table cellspacing=0 cellpadding=3 border>
<tr align=center>
  <th rowspan=2>CellDimension</th>
  <th colspan=4>GridLocation</th>
</tr><tr align=center>
  <th>Vertex</th>
  <th>EdgeCenter</th>
  <th>*FaceCenter</th>
  <th>CellCenter</th>
</tr><tr align=center>
  <td>1</td>
  <td>vertices</td>
  <td>-</td>
  <td>-</td>
  <td>cells (line elements)</td>
</tr><tr align=center>
  <td>2</td>
  <td>vertices</td>
  <td>edges</td>
  <td>-</td>
  <td>cells (area elements)</td>
</tr><tr align=center>
  <td>3</td>
  <td>vertices</td>
  <td>edges</td>
  <td>faces</td>
  <td>cells (volume elements)</td>
</tr>
</table>
</center>

<p>
<i>Note</i>: In the table, *FaceCenter stands for the possible types:
<tt>IFaceCenter</tt>, <tt>JFaceCenter</tt>, <tt>KFaceCenter</tt>,
or <tt>FaceCenter</tt>.

<p>
For structured grids, face centers are indexed using the minimum of the connecting
vertex indices, as described in
<a href="conv.html#structgrid">Structured Grid Notation and Indexing Conventions</a>.
For unstructured grids, edge and face elements are indexed using their
element numbering as defined in the
<a href="gridflow.html#Elements"><tt>Elements_t</tt></a> data structures.

<p>
The BC patch defined by <tt>PointRange/List</tt> is a surface region over which
the particular set of boundary conditions is applied. However, in the current
standard there is no mechanism to specify whether boundary conditions are enforced
in the weak or strong form. If boundary conditions are imposed using collocation
(i.e., strong form), there is also no requirement that they be imposed at the same
locations used to define the BC patch (via <tt>PointRange/List</tt>).
In the case when BC patches are defined in terms of vertices (or edges in 3-D),
then the bounding vertices will be located on multiple BC patches.
If boundary conditions are imposed using collocation at vertices, then for
this case there is no mechanism to determine which BC patch takes precedence
for any of these bounding vertices.

<a name="InwardNormalIndex"></a>
<p>
Some boundary conditions require a normal direction to be specified in
order to be properly imposed.
For structured zones a computational-coordinate normal can be derived
from the BC patch specification by examining redundant index components.
Alternatively, for structured zones this information can be provided
directly by <tt>InwardNormalIndex</tt>.
From Note 4, this vector points into the zone and can have only one
non-zero element.
For exterior faces of a zone in 3-D, <tt>InwardNormalIndex</tt> should take the
following values:

<center>
<table cellspacing=0 cellpadding=0 border=0>
<tr align=left><td colspan=7><hr width=100% noshade>
<tr valign=baseline>
   <th scope=col>Face<td><tt>&nbsp;&nbsp;</tt>
   <th scope=col><tt>InwardNormalIndex</tt>
   <td><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
   <th scope=col>Face<td><tt>&nbsp;&nbsp;</tt>
   <th scope=col><tt>InwardNormalIndex</tt>
<tr align=left><td colspan=7><hr width=100% noshade>
<tr valign=baseline>
   <td align=center><i>i</i>-min<td>
   <td align=center>[+1,0,0]<td>
   <td align=center><i>i</i>-max<td>
   <td align=center>[&minus;1,0,0]
<tr valign=baseline>
   <td align=center><i>j</i>-min<td>
   <td align=center>[0,+1,0]<td>
   <td align=center><i>j</i>-max<td>
   <td align=center>[0,&minus;1,0]
<tr valign=baseline>
   <td align=center><i>k</i>-min<td>
   <td align=center>[0,0,+1]<td>
   <td align=center><i>k</i>-max<td>
   <td align=center>[0,0,&minus;1]
<tr align=left><td colspan=7><hr width=100% noshade>
</table>
</center>

<a name="InwardNormalList"></a>
<p>
The physical-space normal vectors of the BC patch may be described by
<tt>InwardNormalList</tt>; these are located at vertices or cell faces,
consistent with the BC patch specification.
<tt>InwardNormalList</tt> is listed as an optional field because it is not
always needed to enforce boundary conditions, and the physical-space
normals of a BC patch can usually be constructed from the grid.
However, there are some situations, such as grid-coordinate singularity
lines, where <tt>InwardNormalList</tt> becomes a required field, because it
cannot be generated from other information.

<p>
The <tt>BC_t</tt> structure provides for a list of boundary-condition
data sets, described in the next section.
In general, the proper <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>
instance to impose on the BC patch is determined by the
<a href="#t:BCType_assoc"><tt>BCType</tt> association table</a>.
The mechanics of determining the proper data set to impose is described
in the section <a href="#BCType_assoc">Matching Boundary Condition Data
Sets</a>.

<p>
For a few boundary conditions, such as a symmetry plane or polar
singularity, the value of <a href="#BCType"><tt>BCType</tt></a>
completely describes the equations to impose, and no instances of
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> are needed.
For "simple" boundary conditions, where a single set of Dirichlet and/or
Neumann data is applied, a single <tt>BCDataSet_t</tt> will likely appear
(although this is not a requirement).
For "compound" boundary conditions, where the equations to impose
are dependent on local flow conditions, several instances of
<tt>BCDataSet_t</tt> will likely appear; the procedure for choosing
the proper data set is more complex as described in the section
<a href="#BCType_assoc">Matching Boundary Condition Data Sets</a>.

<p>
A <a href="#BCProperty"><tt>BCProperty_t</tt></a> data structure may be
used to record special properties associated with particular boundary
condition patches, such as wall functions or bleed regions.

<a name="FamilyName"></a>
<p>
<tt>FamilyName</tt> identifies the family to which the boundary belongs.
Family names link the mesh boundaries to the CAD surfaces.
(See the section on <a href="misc.html#Family">Family Data Structure
Definition</a> for more details.)
Boundary conditions may also be defined directly on families.
In this case, the <a href="#BCType"><tt>BCType</tt></a> must be
<tt>FamilySpecified</tt>.
If, under a <tt>BC_t</tt> structure, both <tt>FamilyName_t</tt></a> and
<a href="#BCType"><tt>BCType_t</tt></a> are present, and the
<tt>BCType</tt> is <em>not</em> <tt>FamilySpecified</tt>,
then the <tt>BCType</tt> which <em>is</em> specified takes
precedence over any <tt>BCType</tt> which might be stored in a
<a href="misc.html#FamilyBC"><tt>FamilyBC_t</tt></a> structure under the
specified <a href="misc.html#Family"><tt>Family_t</tt></a>.

<p>
Reference data applicable to the boundary conditions of a BC patch is
contained in the <a href="misc.html#ReferenceState"><tt>ReferenceState</tt></a>
structure.
<a href="build.html#DataClass"><tt>DataClass</tt></a> defines the default
for the class of data contained in the boundary conditions.
If the boundary conditions contain dimensional data,
<a href="build.html#DimensionalUnits"><tt>DimensionalUnits</tt></a>
may be used to describe the system of dimensional units employed.
If present, these three entities take precedence of all corresponding
entities at higher levels of the hierarchy, following the standard
<a href="cgnsbase.html#precedence">precedence rules</a>.

<p>
The <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
data structure allows arbitrary user-defined data to be stored in
<tt>Descriptor_t</tt> and <tt>DataArray_t</tt> children without the
restrictions or implicit meanings imposed on these node types at other
node locations.

<p>
<tt>Ordinal</tt> is user-defined and has no restrictions on the values that it
can contain.
It is included for backward compatibility to assist implementation of
the CGNS system into applications whose I/O depends heavily on the
numbering of BC patches.
Since there are no restrictions on the values contained in <tt>Ordinal</tt>
(or that <tt>Ordinal</tt> is even provided), there is no guarantee that the
BC patches for a given zone in an existing CGNS database will have
sequential values from 1 to <i>N</i> without holes or repetitions.
Use of <tt>Ordinal</tt> is discouraged and is on a user-beware basis.

<a name="ListLength"></a>
<h4>FUNCTION <tt>ListLength[]</tt>:</h4>

return value: <tt>int</tt>
<br>
dependencies: <tt>PointRange</tt>, <tt>PointList</tt>

<p>
<tt>BC_t</tt> requires the structure function <tt>ListLength</tt>, which
is used to specify the number of vertices or edge/face elements making up the
BC patch. If <tt>PointRange</tt> is specified, then <tt>ListLength</tt> is
obtained from the number of points (inclusive) between the beginning and
ending indices of <tt>PointRange</tt>.
If <tt>PointList</tt> is specified, then <tt>ListLength</tt> is the
number of indices in the list of points.
In this situation, <tt>ListLength</tt> becomes a user input along with the
indices of the list <tt>PointList</tt>.
By <i>user</i> we mean the application code that is generating the CGNS
database.

<p>
<tt>ListLength</tt> is also the number of elements in the list
<tt>InwardNormalList</tt>.
Note that syntactically <tt>PointList</tt> and
<tt>InwardNormalList</tt> must have the same number of elements.

<p>
If neither <tt>PointRange</tt> or <tt>PointList</tt> is specified in a
particular <tt>BCDataSet_t</tt> substructure, <tt>ListLength</tt> must
be passed into it to determine the length of BC data arrays.

<a name="BCDataSet"></a>
<h3>Boundary Condition Data Set Structure Definition: <tt>BCDataSet_t</tt></h3>

<p>
<tt>BCDataSet_t</tt> contains Dirichlet and Neumann data for a single set of
boundary-condition equations.
Its intended use is for simple boundary-condition types, where the
equations imposed do not depend on local flow conditions.

<pre>
  BCDataSet_t&lt; int CellDimension, int IndexDimension,
    int ListLengthParameter, GridLocation_t GridLocationParameter &gt; :=
    {
    List( Descriptor_t Descriptor1 ... DescriptorN ) ;                 (o)

    BCTypeSimple_t BCTypeSimple ;                                      (r)

    BCData_t&lt;ListLengthBCData[]&gt; DirichletData ;                       (o)
    BCData_t&lt;ListLengthBCData[]&gt; NeumannData ;                         (o)

    GridLocation_t GridLocation ;                                      (o/d)

    IndexRange_t&lt;IndexDimension&gt; PointRange ;                          (o)
    IndexArray_t&lt;IndexDimension, ListLength, int&gt; PointList ;          (o)

    ReferenceState_t ReferenceState ;                                  (o)

    DataClass_t DataClass ;                                            (o)

    DimensionalUnits_t DimensionalUnits ;                              (o)

    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a> and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance
     of <tt>BCDataSet_t</tt> and shall not include the
     names <tt>BCTypeSimple</tt>, <tt>DataClass</tt>,
     <tt>DimensionalUnits</tt>, <tt>DirichletData</tt>,
     <tt>GridLocation</tt>, <tt>NeumannData</tt>, <tt>PointList</tt>,
     <tt>PointRange</tt>, or <tt>ReferenceState</tt>.
<li> <a href="#BCType"><tt>BCTypeSimple</tt></a> is the only required field.
     All other fields are optional and the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a> list
     may be empty.
<li> <tt>GridLocation</tt> is optional; if absent its default value is
     <tt>GridLocationParameter</tt>. For 2-D grids (<tt>CellDimension = 2</tt>),
     <tt>GridLocation</tt> may take the values of <tt>Vertex</tt> or <tt>EdgeCenter</tt>.
     For 3-D grids (<tt>CellDimension = 3</tt>), <tt>GridLocation</tt> may take
     the values of <tt>Vertex</tt>, <tt>EdgeCenter</tt>, <tt>FaceCenter</tt>,
     <tt>IFaceCenter</tt>, <tt>JFaceCenter</tt> or <tt>KFaceCenter</tt>.
<li> <tt>PointRange</tt> and <tt>PointList</tt> are both optional; only one of
     them may be specified. They must define a face subrange of the zone.
</ol>

<p>
<tt>BCDataSet_t</tt> requires the structure parameters <tt>CellDimension</tt>,
<tt>IndexDimension</tt>, <tt>ListLengthParameter</tt>, and <tt>GridLocationParameter</tt>.
These are all used to control the grid location and length of data arrays in the
<tt>Dirichlet</tt> and <tt>Neumann</tt> substructures.
They are inputs for the structure functions
<a href="#ListLength_bcdataset"><tt>ListLength[]</tt></a> and
<a href="#ListLengthBCData"><tt>ListLengthBCData[]</tt></a> defined below.

<p>
<a href="#BCType"><tt>BCTypeSimple</tt></a> specifies the boundary-condition
type, which gives general information on the boundary-condition
equations to be enforced.
<tt>BCTypeSimple</tt> is also used for <a href="#BCType_assoc">matching
boundary condition data sets</a>.

<p>
Boundary-condition data is separated by equation type into Dirichlet and
Neumann conditions.
Dirichlet boundary conditions impose the value of the given variables,
whereas Neumann boundary conditions impose the normal derivative of the
given variables.
The mechanics of specifying Dirichlet and Neumann data for boundary
conditions is covered in the section <a href="#BC_specdata">Boundary
Condition Specification Data</a>.

<p>
The substructures <a href="#BCData"><tt>DirichletData</tt></a> and
<a href="#BCData"><tt>NeumannData</tt></a> contain boundary-condition data
which may be constant over the BC patch, or defined locally at each vertex or
edge/face of the patch. Locally defined data may be specified in one of two ways.
If <tt>GridLocation</tt>, <tt>PointRange</tt> and <tt>PointList</tt> are
all absent, then the data is defined consistent with the BC patch specification
of the parent <a href="#BC"><tt>BC_t</tt></a> structure. In this case,
the location of the locally defined data is given by <tt>GridLocationParameter</tt>
and the length of the data arrays are given by <tt>ListLengthParameter</tt>.
If <tt>GridLocation</tt> and one of <tt>PointRange</tt> or <tt>PointList</tt>
is present, then the length of the data arrays is given by
<a href="#ListLength_bcdataset"><tt>ListLength[]</tt></a>.

<p>
Reference quantities applicable to the set of boundary-condition data are
contained in the <a href="misc.html#ReferenceState"><tt>ReferenceState</tt></a>
structure.
<a href="build.html#DataClass"><tt>DataClass</tt></a> defines the default
for the class of data contained in the boundary-condition data.
If the boundary conditions contain dimensional data,
<a href="build.html#DimensionalUnits"><tt>DimensionalUnits</tt></a>
may be used to describe the system of dimensional units employed.
If present, these three entities take precedence of all corresponding
entities at higher levels of the hierarchy, following the standard
<a href="cgnsbase.html#precedence">precedence rules</a>.

<p>
The <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
data structure allows arbitrary user-defined data to be stored in
<tt>Descriptor_t</tt> and <tt>DataArray_t</tt> children without the
restrictions or implicit meanings imposed on these node types at other
node locations.

<a name="ListLength_bcdataset"></a>
<h4>FUNCTION <tt>ListLength[]</tt>:</h4>

return value: <tt>int</tt>
<br>
dependencies: <tt>PointRange</tt>, <tt>PointList</tt>

<p>
<tt>BCDataSet_t</tt> requires the structure function <tt>ListLength</tt>, which
is used to specify the length of locally defined <tt>Dirichlet</tt> and
<tt>Neumann</tt> data arrays when the grid location of these quatities differs
from that of the BC patch definition. If <tt>PointRange</tt> is specified,
then <tt>ListLength</tt> is obtained from the number of points (inclusive)
between the beginning and ending indices of <tt>PointRange</tt>.
If <tt>PointList</tt> is specified, then <tt>ListLength</tt> is the
number of indices in the list of points.
In this situation, <tt>ListLength</tt> becomes a user input along with the
indices of the list <tt>PointList</tt>.
By <i>user</i> we mean the application code that is generating the CGNS
database.

<p>
If neither <tt>PointRange</tt> or <tt>PointList</tt> is specified in a
particular <tt>BCDataSet_t</tt> substructure, <tt>ListLength</tt> must
be passed into it to determine the length of BC data arrays.

<a name="ListLengthBCData"></a>
<h4>FUNCTION <tt>ListLengthBCData[]</tt>:</h4>

return value: <tt>int</tt>
<br>
dependencies: <tt>ListLengthParameter</tt>, <tt>PointRange</tt>, <tt>PointList</tt>

<p>
<tt>BCDataSet_t</tt> also requires the structure function <tt>ListLengthBCData</tt>.
If <tt>PointRange</tt> or <tt>PointList</tt> is present, then <tt>ListLengthBCData</tt>
takes the value of <tt>ListLength</tt>. If both are absent, then it takes
the value <tt>ListLengthParameter</tt>.

<a name="BCData"></a>
<h3>Boundary Condition Data Structure Definition: <tt>BCData_t</tt></h3>

<p>
<tt>BCData_t</tt> contains a list of variables and associated data for
boundary-condition specification.
Each variable may be given as global data (i.e., a scalar) or local data
defined at each grid point or cell face of the BC patch.
By convention all data specified in a given instance of
<tt>BCData_t</tt> is to be used in the same <em>type</em> of
boundary-condition equation.
For example, the use of separate <tt>BCData_t</tt> substructures for
Dirichlet and Neumann equations in the
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> structure of the previous
section.

<pre>
  BCData_t&lt; int ListLength &gt; :=
    {
    List( Descriptor_t  Descriptor1 ... DescriptorN ) ;                (o)

    List( DataArray_t&lt;DataType, 1, 1&gt;
          DataGlobal1 ... DataGlobalN ) ;                              (o)

    List( DataArray_t&lt;DataType, 1, ListLength&gt;
          DataLocal1 ... DataLocalN ) ;                                (o)

    DataClass_t DataClass ;                                            (o)

    DimensionalUnits_t DimensionalUnits ;                              (o)

    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a>,
     <a href="data.html#DataArray"><tt>DataArray_t</tt></a>, and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance
     of <tt>BCData_t</tt> and shall not include the names
     <tt>DataClass</tt> or <tt>DimensionalUnits</tt>.
<li> There are no required elements; all three lists may be empty.
</ol>

<p>
This structure definition shows separate lists for
<a href="#global&local">global verses local</a> data.
The global data is essentially scalars, while the local data variables
have size determined by the structure parameter <tt>ListLength</tt>.
For <a href="data.html#DataArray"><tt>DataArray_t</tt></a> entities
with <a href="dataname.html">standardized
data-name identifiers</a>, <tt>DataType</tt> is determined by convention.
For user-defined variables, <tt>DataType</tt> is a user input.

<p>
Two important points need to be mentioned regarding this structure
definition.
First, this definition allows a given instance of <tt>BCData_t</tt> to
have a mixture of global and local data.
For example, if a user specifies Dirichlet data that has a uniform
stagnation pressure but has a non-uniform velocity profile, this
structure allows the user to describe the stagnation pressure by a
scalar in the <tt>DataGlobal</tt> list and the velocity by an array in the
<tt>DataLocal</tt> list.
Second, the only distinction between the lists (aside from default
names, which will be seldom used) is the parameters passed into the
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> structure.
Therefore, in actual implementation of this <tt>BCData_t</tt> structure
it may not be possible to distinguish between members of the global
and local lists without querying inside the <tt>DataArray_t</tt>
substructures.
Straightforward mapping onto the ADF or HDF database will not provide any
distinctions between the members of the two lists.
This hopefully will not cause any problems.

<p>
<a href="build.html#DataClass"><tt>DataClass</tt></a> defines the default
for the class of data contained in the boundary-condition data.
If the boundary-condition data is dimensional,
<a href="build.html#DimensionalUnits"><tt>DimensionalUnits</tt></a> may be
used to describe the system of dimensional units employed.
If present, these two entities take precedence of all corresponding
entities at higher levels of the hierarchy, following the standard
<a href="cgnsbase.html#precedence">precedence rules</a>.

<p>
The <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
data structure allows arbitrary user-defined data to be stored in
<tt>Descriptor_t</tt> and <tt>DataArray_t</tt> children without the
restrictions or implicit meanings imposed on these node types at other
node locations.

<a name="BCProperty"></a>
<h3>Boundary Condition Property Structure Definition: <tt>BCProperty_t</tt></h3>

<p>
<tt>BCProperty_t</tt> allows the recording of special properties associated
with particular boundary condition patches.
At the current time, only two properties (<tt>WallFunction_t</tt>
and <tt>Area_t</tt>) are included, but extensions involving
boundary conditions may be implemented as additional nodes under
<tt>BCProperty_t</tt> in the future.

<pre>
  BCProperty_t :=
    {
    List( Descriptor_t  Descriptor1 ... DescriptorN ) ;                (o)

    WallFunction_t WallFunction ;                                      (o)
                
    Area_t Area ;                                                      (o)

    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a> and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance
     of <tt>BCProperty_t</tt> and shall not include the names
     <tt>WallFunction</tt> or <tt>Area</tt>.
</ol>

<p>
The <tt>WallFunction_t</tt> and <tt>Area_t</tt> data structures may be
used to record properties associated with the use of wall functions, or
area-related boundary conditions such as bleed, respectively.

<p>
The <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
data structure allows arbitrary user-defined data to be stored in
<tt>Descriptor_t</tt> and <tt>DataArray_t</tt> children without the
restrictions or implicit meanings imposed on these node types at other
node locations.

<a name="WallFunction"></a>
<h4>Wall Function Structure Definition: <tt>WallFunction_t</tt></h4>

<p>
The <tt>WallFunction_t</tt> data structure allows data associated with
the use of wall function boundary conditions to be recorded.

<pre>
  WallFunction_t :=
    {
    List( Descriptor_t  Descriptor1 ... DescriptorN ) ;                (o)

    WallFunctionType_t WallFunctionType ;                              (r)
                
    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a> and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance
     of <tt>WallFunction_t</tt> and shall not include the name
     <tt>WallFunctionType</tt>.
</ol>

<p>
<tt>WallFunctionType_t</tt> is a required enumeration data structure
that is used to define the type of wall functions being used.

<pre>
  WallFunctionType_t := Enumeration(
    WallFunctionTypeNull,
    WallFunctionTypeUserDefined,
    Generic ) ;
</pre>
Because there is such a wide array of methods for employing wall
functions (few of which are well-documented), the type <tt>Generic</tt>
is used to simply indicate that a wall function is employed, without
specifying details.

<a name="Area"></a>
<h4>Area Structure Definition: <tt>Area_t</tt></h4>

<p>
The <tt>Area_t</tt> data structure allows data associated with
area-related boundary conditions such as bleed to be recorded.

<pre>
  Area_t :=
    {
    List( Descriptor_t  Descriptor1 ... DescriptorN ) ;                (o)

    AreaType_t AreaType ;                                              (r)
    DataArray_t&lt;real, 1, 1&gt;  SurfaceArea ;                             (r)
    DataArray_t&lt;real, 1, 32&gt; RegionName ;                              (r)
                
    List( UserDefinedData_t UserDefinedData1 ... UserDefinedDataN ) ;  (o)
    } ;
</pre>

<i>Notes</i>

<ol>
<li> Default names for the
     <a href="build.html#Descriptor"><tt>Descriptor_t</tt></a> and
     <a href="misc.html#UserDefinedData"><tt>UserDefinedData_t</tt></a>
     lists are as shown; users may choose other legitimate names.
     Legitimate names must be unique within a given instance of
     <tt>Area_t</tt> and shall not include the names <tt>AreaType</tt>,
     <tt>RegionName</tt>, or <tt>SurfaceArea</tt>.
</ol>

<p>
<tt>AreaType_t</tt> is a required enumeration data structure
that is used to define the type of area being defined.

<pre>
  AreaType_t := Enumeration(
    AreaTypeNull,
    AreaTypeUserDefined,
    BleedArea,
    CaptureArea ) ;
</pre>

<p>
If <tt>AreaType</tt> is set to <tt>BleedArea</tt>, the value of
<tt>SurfaceArea</tt> is the size of the current bleed surface.
Note that bleed is commonly used with wall boundary conditions.
The bleed area is the surface area of the boundary condition patch.

<p>
If <tt>AreaType</tt> is set to <tt>CaptureArea</tt>, then
<tt>SurfaceArea</tt> represents the size of the current capture surface.
For inlet flows, for example, the capture area is the area of a
fictitious surface in front of the inlet in which mass is pulled into
the inlet.
This is used to calculate the mass flow for the boundary condition patch
based on the formula:<br><br>
<center>
mass flow = <i>MFR &rho;</i><sub>&infin;</sub><i>U</i><sub>&infin;</sub><i>A<sub>cap</sub></i>
</center><br>
where <i>MFR</i> is the desired mass flow ratio and
<i>A<sub>cap</sub></i> is the capture area.
Another interpretation is the far-upstream cross-sectional area of the
stream tube which feeds the inlet.
Note that the capture area is usually defined with an outflow boundary
condition, which is commonly used at an engine face.

<p>
The <tt>RegionName</tt> is character identifier, and is needed so that a
specific region can span multiple surfaces over multiple zones.


<a name="BCType"></a>
<h3>Boundary Condition Type Structure Definition: <tt>BCType_t</tt></h3>

<p>
<tt>BCType_t</tt> is an enumeration type that identifies the
boundary-condition equations to be enforced at a given boundary
location.
<pre>
  BCType_t := Enumeration(
    BCTypeNull, BCTypeUserDefined, BCAxisymmetricWedge, BCDegenerateLine.
    BCDegeneratePoint, BCDirichlet, BCExtrapolate, BCFarfield, BCGeneral,
    BCInflow, BCInflowSubsonic, BCInflowSupersonic, BCNeumann,
    BCOutflow, BCOutflowSubsonic, BCOutflowSupersonic, BCSymmetryPlane,
    BCSymmetryPolar, BCTunnelInflow, BCTunnelOutflow, BCWall,
    BCWallInviscid, BCWallViscous, BCWallViscousHeatFlux,
    BCWallViscousIsothermal, FamilySpecified ) ;
</pre>
The boundary-condition type is further defined as simple,
<tt>BCTypeSimple_t</tt>, or compound, <tt>BCTypeCompound_t</tt>,
which are subsets of the enumeration type <tt>BCType_t</tt>.
<pre>
  BCTypeSimple_t := Enumeration(
    BCTypeNull, BCTypeUserDefined, BCAxisymmetricWedge, BCDegenerateLine.
    BCDegeneratePoint, BCDirichlet, BCExtrapolate, BCGeneral,
    BCInflowSubsonic, BCInflowSupersonic, BCNeumann,
    BCOutflowSubsonic, BCOutflowSupersonic, BCSymmetryPlane,
    BCSymmetryPolar, BCTunnelInflow, BCTunnelOutflow, BCWall,
    BCWallInviscid, BCWallViscous, BCWallViscousHeatFlux,
    BCWallViscousIsothermal, FamilySpecified ) ;
</pre>
<pre>
  BCTypeCompound_t := Enumeration(
    BCTypeNull, BCTypeUserDefined, BCInflow, BCOutflow,
    BCFarfield ) ;
</pre>

<p>
The members of <tt>BCTypeSimple_t</tt> completely identify the equations to
impose, while those of <tt>BCTypeCompound_t</tt> give a general description of the class of
boundary-condition equations to impose.
The specific boundary-condition equations to enforce for each
value of <tt>BCType_t</tt> are listed in separate tables for
<a href="#t:BCTypeSimple">Simple Boundary Condition Types</a> and
<a href="#t:BCTypeCompound">Compound Boundary Condition Types</a>.

<p>
The subdivision of <tt>BCType_t</tt> is based on function.
For simple boundary conditions, the equations and data imposed are
fixed; whereas, for compound boundary conditions different sets of
equations are imposed depending on local flow conditions at the
boundary.
This distinction requires <a href="#BCType_assoc">additional rules for
dealing with simple and compound boundary-condition types</a>.

<p>
For the inflow/outflow boundary-condition descriptions, 3-D inviscid
compressible flow is assumed; the 2-D equivalent should be obvious.
These same boundary conditions are typically used for viscous cases
also.
This "3-D Euler" assumption will be noted wherever used.

<p>
In the following tables, <i>Q</i> is the solution vector,
<b><i>q</i></b> is the velocity vector whose magnitude is <i>q</i>, the
unit normal to the boundary is <b><i>n</i></b>, and
&part;() / &part;<i>n</i> = <b><i>n</i></b> &sdot; &nabla is differentiation
normal to the boundary.

<br><br>
<a name="t:BCTypeSimple"></a>
<center>
<table cellspacing=0 cellpadding=0 border=0>
<caption>
Simple Boundary Condition Types
<br><br>
</caption>
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <th scope=col align=left abbr="Identifier"><tt>BCType_t</tt> or
       <tt>BCTypeSimple_t</tt> Identifier<td><tt>&nbsp;&nbsp;</tt>
   <th scope=col align=left abbr="Description">Boundary Condition Description
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <td>BCGeneral<td>
   <td>Arbitrary conditions on <i>Q</i> or &part;<i>Q</i> / &part;<i>n</i>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCDirichlet<td>
   <td>Dirichlet condition on <i>Q</i> vector
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCNeumann<td>
   <td>Neumann condition on &part;<i>Q</i> / &part;<i>n</i>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCExtrapolate<td>
   <td>Extrapolate <i>Q</i> from interior
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCWallInviscid<td>
   <td>Inviscid (slip) wall
       <ul>
       <li> normal velocity specified (default:
            <b><i>q</i></b> &sdot; <b><i>n</i></b> = 0)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCWallViscousHeatFlux<td>
   <td>Viscous no-slip wall with heat flux
       <ul>
       <li> velocity Dirichlet (default: <i>q</i> = 0)
       <li> temperature Neumann (default: adiabatic,
            &part;<i>T</i> / &part;<i>n</i> = 0)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCWallViscousIsothermal<td>
   <td>Viscous no-slip, isothermal wall
       <ul>
       <li> velocity Dirichlet (default: <i>q</i> = 0)
       <li> temperature Dirichlet
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCWallViscous<td>
   <td>Viscous no-slip wall; special cases are <tt>BCWallViscousHeatFlux</tt>
       and <tt>BCWallViscousIsothermal</tt>
       <ul>
       <li> velocity Dirichlet (default: <i>q</i> = 0)
       <li> Dirichlet or Neumann on temperature
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCWall<td>
   <td>General wall condition; special cases are <tt>BCWallInviscid</tt>, 
       <tt>BCWallViscous</tt>, <tt>BCWallViscousHeatFlux</tt>, and
       <tt>BCWallViscousIsothermal</tt>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCInflowSubsonic<td>
   <td>Inflow with subsonic normal velocity
       <ul>
       <li> specify 4; extrapolate 1 (3-D Euler)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCInflowSupersonic<td>
   <td>Inflow with supersonic normal velocity
       <ul>
       <li> specify 5; extrapolate 0 (3-D Euler)
       </ul>
       Same as <tt>BCDirichlet</tt>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCOutflowSubsonic<td>
   <td>Outflow with subsonic normal velocity
       <ul>
       <li> specify 1; extrapolate 4 (3-D Euler)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCOutflowSupersonic<td>
   <td>Outflow with supersonic normal velocity
       <ul>
       <li> specify 0; extrapolate 5 (3-D Euler)
       </ul>
       Same as <tt>BCExtrapolate</tt>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCTunnelInflow<td>
   <td>Tunnel inlet (subsonic normal velocity)
       <ul>
       <li> specify cross-flow velocity, stagnation enthalpy, entropy 
       <li> extrapolate 1 (3-D Euler)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCTunnelOutflow<td>
   <td>Tunnel exit (subsonic normal velocity)
       <ul>
       <li> specify static pressure
       <li> extrapolate 4 (3-D Euler)
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCDegenerateLine<td>
   <td>Face degenerated to a line <tt>&nbsp;</tt>
       <img align=top src="bc.figs/face2line.gif"
       alt="3-D region with a rectangular front face; top and bottom edges merge to a line at the back 'face'"">
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCDegeneratePoint<td>
   <td>Face degenerated to a point <tt>&nbsp;</tt>
       <img align=top src="bc.figs/face2point.gif"
       alt="3-D region with a rectangular front face; all four edges merge to a point at the back 'face'"">
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCSymmetryPlane<td>
   <td>Symmetry plane; face should be coplanar
       <ul>
       <li> density, pressure: &part;() / &part;<i>n</i> = <b><i>n</i></b> &sdot; &nabla = 0
       <li> tangential velocity: &part;(<b><i>q</i></b> &times; <b><i>n</i></b>) / &part;<i>n</i> = 0
       <li> normal velocity: <b><i>q</i></b> &sdot; <b><i>n</i></b> = 0
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCSymmetryPolar<td>
   <td>Polar-coordinate singularity line; special case of
       <tt>BCDegenerateLine</tt> where degenerate face is
       a straight line and flowfield has polar symmetry;
       <b><i>s</i></b> is singularity line
       tangential unit vector
       <ul>
       <li> normal velocity: <b><i>q</i></b> &times; <b><i>s</i></b> = 0
       <li> all others: &part;() / &part;<i>n</i> = <b><i>n</i></b> &sdot; &nabla = 0,
            <b><i>n</i></b> normal to <b><i>s</i></b>
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCAxisymmetricWedge<td>
   <td>Axisymmetric wedge; special case of <tt>BCDegenerateLine</tt>
       where degenerate face is a straight line
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>FamilySpecified<td>
   <td>A boundary condition type is being specified for the family to
       which the current boundary belongs.
       A <tt>FamilyName_t</tt> specification must exist under
       <a href="#BC"><tt>BC_t</tt></a>, corresponding to a
       <a href="misc.html#Family"><tt>Family_t</tt></a> structure under
       <a href="cgnsbase.html#CGNSBase"><tt>CGNSBase_t</tt></a>.
       Under the <tt>Family_t</tt> structure there must
       be a <a href="misc.html#FamilyBC"><tt>FamilyBC_t</tt></a>
       structure specifying a valid <tt>BCType</tt> (other than
       <tt>FamilySpecified</tt>!).
       If any of these are absent, the boundary condition type is
       undefined.
<tr align=left><td colspan=3><hr width=100% noshade>
</table>
</center>

<br><br>
<a name="t:BCTypeCompound"></a>
<center>
<table cellspacing=0 cellpadding=0 border=0>
<caption>
Compound Boundary Condition Types
<br><br>
</caption>
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <th scope=col align=left abbr="Identifier"><tt>BCType_t</tt> or
       <tt>BCTypeCompound_t</tt> Identifier<td><tt>&nbsp;&nbsp;</tt>
   <th scope=col align=left abbr="Description">Boundary Condition Description
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <td>BCInflow<td>
   <td>Inflow, arbitrary normal Mach; test on normal Mach, then perform
       one of: <tt>BCInflowSubsonic</tt>, <tt>BCInflowSupersonic</tt>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCOutflow<td>
   <td>Outflow, arbitrary normal Mach; test on normal Mach, then perform
       one of: <tt>BCOutflowSubsonic</tt>, <tt>BCOutflowSupersonic</tt>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCFarfield<td>
   <td>Farfield inflow/outflow, arbitrary normal Mach; test on
       normal velocity and normal Mach, then perform one of:
       <tt>BCInflowSubsonic</tt>, <tt>BCInflowSupersonic</tt>,
       <tt>BCOutflowSubsonic</tt>, <tt>BCOutflowSupersonic</tt>
<tr align=left><td colspan=3><hr width=100% noshade>
</table>
</center>

<a name="BCType_assoc"></a>
<h3>Matching Boundary Condition Data Sets</h3>

<p>
The <a href="#BC"><tt>BC_t</tt></a> structure allows for a
arbitrary list of boundary-condition data sets, described by the
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> structure.
For simple boundary conditions, a single data set must be chosen from a
list that may contain more than one element.
Likewise, for a compound boundary condition, a limited number of data
sets must be chosen and applied appropriately.
The mechanism for proper choice of data sets is controlled by
the <a href="#BCType"><tt>BCType</tt></a> field of the <tt>BC_t</tt>
structure, the <tt>BCTypeSimple</tt> field of the <tt>BCDataSet_t</tt>
structure, and the <a href="#t:BCType_assoc">boundary-condition type
association table</a>.
In the following discussion, we will use the "<tt>/</tt>" notation for
fields or elements of a structure type.

<p>
<a href="#BC"><tt>BC_t</tt></a> is used for both simple and compound
boundary conditions; hence, the field <tt>BC_t/BCType</tt> is of type
<tt>BCType</tt>.
Conversely, the substructure <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>
is intended to enforce a single set of boundary-condition equations
independent of local flow conditions (i.e., it is appropriate only for
simple boundary conditions).
This is why the field <tt>BCDataSet_t/BCTypeSimple</tt> is of type
<tt>BCTypeSimple_t</tt> and not <tt>BCType_t</tt>.
The appropriate choice of data sets is determined by matching the field
<tt>BC_t/BCType</tt> with the field <tt>BCDataSet_t/BCTypeSimple</tt>
as specified in the <a href="#t:BCType_assoc">boundary-condition type
association table</a>.

<p>
For simple boundary conditions, a single match from the list of
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> instances is required.
For all <a href="#t:BCTypeSimple"><tt>BCTypeSimple_t</tt> identifiers</a>,
except <tt>BCInflowSupersonic</tt> and <tt>BCOutflowSupersonic</tt>, an
exact match is necessary.
<tt>BCInflowSupersonic</tt> will match itself or <tt>BCDirichlet</tt>;
<tt>BCOutflowSupersonic</tt> will match itself or <tt>BCExtrapolate</tt>.

<p>
For compound boundary conditions, the association table specifies which
simple boundary-condition types are appropriate.
Since compound boundary conditions enforce different boundary-condition
equation sets depending on local flow conditions, several instances of
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> will be matched for each
<a href="#t:BCTypeCompound"><tt>BCTypeCompound_t</tt> identifier</a>.
The accompanying rule determines which of the matching data sets to
apply at a given location on the BC patch.

<p>
This provides a general procedure applicable to both <tt>BCTypeSimple_t</tt>
and <tt>BCTypeCompound_t</tt> situations.
For a given <a href="#BC"><tt>BC_t/BCType</tt></a> use those instances of
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a> whose field
<tt>BCDataSet_t/BCTypeSimple</tt> matches according to the following table.
Apply the matching data set or sets as prescribed by the appropriate
usage rule.

<br><br>
<a name="t:BCType_assoc"></a>
<center>
<table cellspacing=0 cellpadding=0 border=0>
<caption>
Associated Boundary Condition Types and Usage Rules
<br><br>
</caption>
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <th scope=col align=left><tt>BCType_t</tt> Identifier<td><tt>&nbsp;&nbsp;</tt>
   <th scope=col align=left abbr="BCTypeSimple_t Identifiers">Associated
       <tt>BCTypeSimple_t</tt> Identifiers and Usage Rules
<tr align=left><td colspan=3><hr width=100% noshade>
<tr valign=baseline>
   <td>BCInflow<td>
   <td><tt>BCInflowSupersonic</tt><br>
       <tt>BCInflowSubsonic</tt><br><br>
       <i>Usage Rule:</i>
       <ul>
       <li> if supersonic normal Mach, choose <tt>BCInflowSupersonic</tt>;
       <li> else, choose <tt>BCInflowSubsonic</tt>
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCOutflow<td>
   <td><tt>BCOutflowSupersonic</tt><br>
       <tt>BCOutflowSubsonic</tt><br><br>
       <i>Usage Rule:</i>
       <ul>
       <li> if supersonic normal Mach, choose <tt>BCOutflowSupersonic</tt>;
       <li> else, choose <tt>BCOutflowSubsonic</tt>
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCFarfield<td>
   <td><tt>BCInflowSupersonic</tt><br>
       <tt>BCInflowSubsonic</tt><br>
       <tt>BCOutflowSupersonic</tt><br>
       <tt>BCOutflowSubsonic</tt><br><br>
       <i>Usage Rule:</i>
       <ul>
       <li> if inflow and supersonic normal Mach, choose <tt>BCInflowSupersonic</tt>;
       <li> else if inflow, choose <tt>BCInflowSubsonic</tt>;
       <li> else if outflow and supersonic normal Mach, choose <tt>BCOutflowSupersonic</tt>;
       <li> else, choose <tt>BCOutflowSubsonic</tt>
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCInflowSupersonic<td>
   <td><tt>BCInflowSupersonic</tt><br>
       <tt>BCDirichlet</tt><br><br>
       <i>Usage Rule:</i>
       <ul>
       <li> choose either; <tt>BCInflowSupersonic</tt> takes precedence
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>BCOutflowSupersonic<td>
   <td><tt>BCOutflowSupersonic</tt><br>
       <tt>BCExtrapolate</tt><br><br>
       <i>Usage Rule:</i>
       <ul>
       <li> choose either; <tt>BCOutflowSupersonic</tt> takes precedence
       </ul>
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td>All others<td>
   <td>Self-matching
<tr align=left><td colspan=3><hr width=100% noshade>
</table>
</center>

<p>
Although we present a strict division between the two categories of
boundary-condition types, we realize that some overlap may exist.
For example, some of the more general simple boundary-condition types,
such as <tt>BCWall</tt>, may include a situation of inflow/outflow (say
if the wall is porous).
These complications require further guidelines on appropriate definition
and use of boundary-condition types.
The real distinctions between
<a href="#t:BCTypeSimple"><tt>BCTypeSimple_t</tt></a> and
<a href="#t:BCTypeCompound"><tt>BCTypeCompound_t</tt></a> are as follows:

<ul>
<li> <tt>BCTypeSimple_t</tt> identifiers always match themselves;
     <tt>BCTypeCompound_t</tt> identifiers never match themselves.<br><br>
<li> <tt>BCTypeSimple_t</tt> identifiers always produce a single match;
     <tt>BCTypeCompound_t</tt> will produce multiple matches.<br><br>
<li> The usage rule for <tt>BCTypeSimple_t</tt> identifiers is always
     trivial - apply the single matching data set regardless of local
     flow conditions.
</ul>

Therefore, any boundary condition that involves application of different
data sets depending on local flow conditions should be classified
<a href="#t:BCTypeCompound"><tt>BCTypeCompound_t</tt></a>.
If a type that we have classified
<a href="#t:BCTypeSimple"><tt>BCTypeSimple_t</tt></a> is used as a
compound type (<tt>BCWall</tt> for a porous wall is an example), then it
should somehow be reclassified.
One option is to define a new <tt>BCTypeCompound_t</tt> identifier and
provide associated <tt>BCTypeSimple_t</tt> types and a usage rule.
Another option may be to allow some identifiers to be both
<tt>BCTypeSimple_t</tt> and <tt>BCTypeCompound_t</tt> and let their
appropriate use be based on context.
This is still undetermined.

<a name="BC_specdata"></a>
<h3>Boundary Condition Specification Data</h3>

<p>
For a given simple boundary condition (i.e., one that is not
dependent on local flow conditions), the database provides a set of
boundary-condition equations to be enforced through the structure
definitions for <a href="#BCDataSet"><tt>BCDataSet_t</tt></a> and
<a href="#BCData"><tt>BCData_t</tt></a>.
Apart from the boundary-condition type, the precise equations to be
enforced are described by boundary-condition solution data.
These specified solution data are arranged by "equation type":

<br><br>
<table cellspacing=0 cellpadding=0 border=0>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td>Dirichlet:<td><tt>&nbsp;&nbsp;</tt>
   <td><i>Q</i> = <i>Q</i><sub>specified</sub>
<tr valign=baseline><td>
   <td>Neumann:<td>
   <td>&part;<i>Q</i> / &part;<i>n</i> = 
       (&part;<i>Q</i> / &part;<i>n</i>)<sub>specified</sub>
</table>

<p>
The <tt>DirichletData</tt> and <tt>NeumannData</tt> entities of
<a href="#BCData"><tt>BCData_t</tt></a> list both the solution variables
involved in the equations (through the <a href="dataname.html">data-name
identifier conventions</a>) and the specified solution data.

<p>
Two issues need to be addressed for specifying Dirichlet or Neumann
boundary-condition data.
The first is whether the data is global or local: 

<br><br>
<a name="global&local"></a>
<table cellspacing=0 cellpadding=0 border=0>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td nowrap>Global BC data:<td><tt>&nbsp;&nbsp;</tt>
   <td>Data applied globally to the BC patch; for example, specifying
       a uniform total pressure at an inflow boundary
<tr valign=baseline><td>
   <td nowrap>Local BC data:<td>
   <td>Data applied locally at each vertex or cell face of the BC patch;
       an example of this is varying total pressure specified at each
       grid point at an inflow boundary
</table>
<br>
The second issue is describing the actual solution quantities that are
to be specified.
Both of these issues are addressed by use of the
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> structure.

<p>
For some types of boundary conditions, many different combinations of
solution quantities could be specified.
For example, <tt>BCInflowSubsonic</tt> requires 4 solution quantities to
be specified in 3-D, but what those 4 quantities are varies with
applications (e.g., internal verses external flows) and codes.
We propose the convention that the actual data being specified for
any <a href="#BCType"><tt>BCType</tt></a> is given by the list of
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> entities included
in <a href="#BCData"><tt>DirichletData</tt> and <tt>NeumannData</tt></a>
structures (actually by the identifier attached to each instance of
<tt>DataArray_t</tt>).
This frees us from having to define <em>many</em> versions
of a given <tt>BCType</tt> (e.g., <tt>BCInflowSubsonic1</tt>,
<tt>BCInflowSubsonic2</tt>, etc.), where each has a precisely defined
set of Dirichlet data.
We are left with the easier task of defining <em>how many</em> Dirichlet or
Neumann quantities must be provided for each <tt>BCType</tt>.

<p>
An example of using
<a href="dataname.html"><tt>DataArray_t</tt>-identifier conventions</a>
to describe BC specification data is the following: subsonic
inflow with uniform stagnation pressure, mass flow and cross-flow angle
specified; the Dirichlet data are stagnation pressure = 2.56,
mass flow = 1.34, and cross-flow angle has a <i>y</i>-component of
0.043 and a <i>z</i>-component of 0.02 (ignore dimensional-units or
normalization for the present).
The specified solution variables and associated data are described as
shown:
<pre>
  BCData_t&lt;ListLength=?&gt; DirichletData = 
    {{
    DataArray_t&lt;real, 1, 1&gt; PressureStagnation = {{ Data(real, 1, 1) = 2.56  }} ;
    DataArray_t&lt;real, 1, 1&gt; MassFlow           = {{ Data(real, 1, 1) = 1.34  }} ;
    DataArray_t&lt;real, 1, 1&gt; VelocityAngleY     = {{ Data(real, 1, 1) = 0.043 }} ;
    DataArray_t&lt;real, 1, 1&gt; VelocityAngleZ     = {{ Data(real, 1, 1) = 0.02  }} ;
    }} ;
</pre>
Basically, this states that <tt>DirichletData</tt> contains four
instances of <a href="data.html#DataArray"><tt>DataArray_t</tt></a> with
identifiers or names <tt>PressureStagnation</tt>, <tt>MassFlow</tt>,
<tt>VelocityAngleY</tt> and <tt>VelocityAngleZ</tt>.
Each <tt>DataArray_t</tt> structure entity contains a single
floating-point value; these are the Dirichlet data for the BC.
Note that <tt>Data(real, 1, 1)</tt> means a single floating-point value.

<p>
The <a href="#global&local">global verses local</a> data issue can be
easily handled by storing either a scalar, as shown above, for the
global BC data case; or storing an array for the local BC data case.
Storing an array of local BC data allows the capability for specifying
non-constant solution profiles, such as "analytic" boundary-layer
profiles or profiles derived from experimental data.
For the above example, if the stagnation pressure is instead specified
at every vertex of the boundary-condition patch the following results:
<pre>
  BCData_t&lt;ListLength=99&gt; DirichletData = 
    {{
    DataArray_t&lt;real, 1, 99&gt; PressureStagnation = 
      {{ Data(real, 1, 99) = (PTOT(n), n=1,99) }} ;
    DataArray_t&lt;real, 1, 1&gt; MassFlow           = {{ Data(real, 1, 1) = 1.34  }} ;
    DataArray_t&lt;real, 1, 1&gt; VelocityAngleY     = {{ Data(real, 1, 1) = 0.043 }} ;
    DataArray_t&lt;real, 1, 1&gt; VelocityAngleZ     = {{ Data(real, 1, 1) = 0.02  }} ;
    }} ;
</pre>
where, say, the boundary face is logically rectangular and contains
11 &times; 9 vertices and the stagnation pressure at the vertices is
given by the array <tt>PTOT()</tt>.

<p>
To facilitate implementation of boundary conditions into existing flow
solvers, we adopt the convention that if no boundary-condition data
is specified, then flow solvers are free to enforce any appropriate
boundary-condition equations.
This includes situations where entities of
<a href="#BCDataSet"><tt>BCDataSet_t</tt></a>,
<a href="#BCData"><tt>BCData_t</tt></a> or
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> are absent within the
boundary-condition hierarchy.
By convention, if no <a href="#BCDataSet"><tt>BCDataSet</tt></a>
entities are present, then application codes are free to enforce
appropriate BCs for the given value of <a href="#BCType"><tt>BCType</tt></a>.
Furthermore, if the entities <tt>DirichletData</tt> and
<tt>NeumannData</tt> are not present in an instance of
<tt>BCDataSet_t</tt>, or if insufficient data is present in
<tt>DirichletData</tt> or <tt>NeumannData</tt> (e.g., if only one
Dirichlet variable is present for a subsonic inflow condition), then
application codes are free to fill out the boundary-condition data as
appropriate for the <a href="#t:BCTypeSimple"><tt>BCTypeSimple</tt></a>
identifier.

<p>
The various levels of BC implementation allowed are shown in the
following figure, from the lowest level in which the application codes
interpret the <a href="#BCType"><tt>BCType</tt></a>, to the fully
SIDS-compliant BC implementation which completely defines the BC within
the CGNS file.

<a name="f:BCimplementations"></a>
<br><br>
<center>
<table cellspacing=0 cellpadding=0 border=0>
<tr valign=baseline>
   <td align=center><img src="bc.figs/bcimpl_low.gif"
                     alt="CGNS dataset nodes for lowest boundary condition implementation level allowed"
                     longdesc="bc.figs/bcimpl_low.html">
   <td><tt>&nbsp;&nbsp;</tt>
   <td align=center><img src="bc.figs/bcimpl_full.gif"
                     alt="CGNS dataset nodes for fully SIDS-compliant boundary condition implementation"
                     longdesc="bc.figs/bcimpl_full.html">
<tr valign=baseline><td><tt>&nbsp;</tt>
<tr valign=baseline>
   <td align=center scope=col><small>Lowest-level allowed (application
       code interprets meaning of <tt>BCType</tt>)</small><td>
   <td align=center scope=col><small>Fully SIDS-compliant</small>
</table>
<br>
Boundary Condition Implementation Levels
</center>

<p>
An alternative approach to the present design could be to list all the
solution variables and data (as
<a href="data.html#DataArray"><tt>DataArray_t</tt></a>-like structures)
for the boundary condition, and contain descriptive tags in each one to
indicate if they are Dirichlet or Neumann data.
We have not taken this approach.
We think grouping boundary-condition data by "equation type" as we have
done better allows for future extension to other types of boundary
conditions (e.g., 2nd-order non-reflecting BC's that result in P.D.E.'s
to be solved at the boundary).

<a name="BCexample"></a>
<h3>Boundary Condition Examples</h3>

<p>
This section contains boundary-condition examples with increasing
complexity.
Included is the most simple <a href="#BC"><tt>BC_t</tt></a> entity
and one of the most complex.
The examples show situations of <a href="#global&local">local and
global</a> boundary-condition data, <a href="#t:BCTypeSimple">simple</a>
and <a href="#t:BCTypeCompound">compound</a> boundary-condition types,
and multiple boundary-condition data sets that must be
<a href="#BCType_assoc">matched</a> with the appropriate
boundary-condition type.

<a name="ex:bc1"></a>
<h4>Example - Symmetry Plane</h4>

<p>
Symmetry plane for a patch on the <i>i</i>-min face of a 3-D structured zone.
<pre>
  !  CellDimension = 3, IndexDimension = 3
  BC_t&lt;3,3,3&gt; BC1 =
    {{
    BCType_t BCType = BCSymmetryPlane ;

    IndexRange_t&lt;3&gt; PointRange =
      {{
      int[3] Begin = [1,1,1 ] ;
      int[3] End   = [1,9,17] ;
      }} ;
    }} ;
</pre>
Since the boundary-condition equations to be enforced are completely
defined by the boundary-condition type <tt>BCSymmetryPlane</tt>, no other
information needs to be provided, except for the extent of the BC patch.
The BC patch is specified by <tt>PointRange</tt> with a beginning index of
(1,1,1) and an ending index of (1,9,17).
By default, these refer to vertices.

<a name="ex:bc2"></a>
<h4>Example - Viscous Solid Wall I</h4>

<p>
A viscous solid wall for a 3-D structured zone, where a Dirichlet
condition is enforced for temperature; the wall temperature for the
entire wall is specified to be 273 K.
The BC patch is on the <i>j</i>-min face and is bounded by the indices
(1,1,1) and (33,1,9).
<pre>
  !  CellDimension = 3, IndexDimension = 3
  BC_t&lt;3,3,3&gt; BC2 =
    {{
    BCType_t BCType = BCWallViscousIsothermal ;

    IndexRange_t&lt;3&gt; PointRange =
      {{
      int[3] Begin = [1 ,1,1] ;
      int[3] End   = [33,1,9] ;
      }} ;

    !  ListLength = 33*9 = 297
    BCDataSet_t&lt;297&gt; BCDataSet1 =
      {{
      BCTypeSimple_t BCTypeSimple = BCWallViscousIsothermal ;

      !  Data array length = ListLength = 297
      BCData_t&lt;297&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; Temperature =
          {{
          Data(real, 1, 1) = 273. ;

          DataClass_t DataClass = Dimensional ;

          DimensionalUnits_t DimensionalUnits =
            {{
            MassUnits        = MassUnitsNull ;
            LengthUnits      = LengthUnitsNull ;
            TimeUnits        = TimeUnitsNull ;
            TemperatureUnits = Kelvin ;
            AngleUnits       = AngleUnitsNull ;
            }} ;
          }} ;
        }} ;
      }} ;
    }} ;
</pre>

<p>
This is an example of a <a href="#t:BCTypeSimple">simple
boundary-condition type</a>, <tt>BCWallViscousIsothermal</tt>.
By default there is a zero Dirichlet condition on the velocity, and
<a href="#BCDataSet"><tt>BCDataSet1</tt></a> states there is a
Dirichlet condition on temperature with a global value of 273 K.
The data set contains a single <a href="#BCData"><tt>BCData_t</tt></a>
entity, called <tt>DirichletData</tt>, meaning a (possibly empty)
collection of Dirichlet conditions should be enforced.
Within <tt>DirichletData</tt>, there is a single
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> entity; this
narrows the specification to a single Dirichlet condition.
This lone entity has the identifier <tt>Temperature</tt>, which by the
<a href="dataname.html">data-name identifier conventions</a> is the
identifier for static temperature.
The data contained in <tt>Temperature</tt> is a floating-point scalar
with a value of 273.
The qualifiers <a href="build.html#DataClass"><tt>DataClass</tt></a>
and <a href="build.html#DimensionalUnits"><tt>DimensionalUnits</tt></a>
specifies that the temperature is dimensional with units of <tt>Kelvin</tt>.

<p>
Since <tt>BCWallViscousIsothermal</tt> is a simple boundary-condition
type, the appropriate data set contains a
<a href="#BCType"><tt>BCTypeSimple</tt></a> entity whose value is
<tt>BCWallViscousIsothermal</tt>.
For this example, only a single data set is provided, and this data set
has the correct boundary-condition type.
This is an example of a trivial data-set match.

<p>
Apart from velocity and temperature, additional "numerical" boundary
conditions are typically required by Navier-Stokes flow solvers, but
none are given here; therefore, a code is free to implement other
additional boundary conditions as desired.

<p>
Although the boundary-condition data is global, we include in this
example structure parameters that are the lengths of potential
local-data arrays.
Comments are added to the example with the "<tt>!</tt>" notation to document
the structure parameters.
The <a href="#BC"><tt>BC_t</tt></a> structure function
<a href="#ListLength"><tt>ListLength</tt></a> is evaluated based on
<tt>PointRange</tt>.
Since <a href="build.html#GridLocation"><tt>GridLocation</tt></a> is not
specified in <tt>BC2</tt>, any local data is at vertices by default.
The entity <tt>Temperature</tt> contains global data, so the value of
<tt>ListLength</tt> is unused in <tt>DirichletData</tt>.

<p>
This example raises the question of whether unused structure parameters
are required in structure entities.
The answer is no.
We included them here for completeness.
The purpose of structure parameters is to mimic the need to define
elements of a entity based on information contained elsewhere (at a
higher level) in the CGNS database.
When this need is not present in a given instance of a structure entity,
the structure parameters are superfluous.
In some of the following examples, structure parameters that are
superfluous or otherwise not needed are denoted by "<tt>?</tt>".

<a name="ex:bc3"></a>
<h4>Example - Subsonic Inflow</h4>

<p>
Subsonic inflow for a 2-D structured zone: The BC patch is on
the <i>i</i>-min face and includes
<i>j</i> &isin; [2, 7].
As prescribed by the boundary-condition type, three quantities must be
specified.
Uniform entropy and stagnation enthalpy are specified with values of
0.94 and 2.85, respectively.
A velocity profile is specified at face midpoints, given by the array
<tt>v_inflow(j)</tt>.
No dimensional or nondimensional information is provided.
<pre>
  !  CellDimension = 2, IndexDimension = 2
  BC_t&lt;2,2,?&gt; BC3 =
    {{
    BCType_t BCType = BCInflowSubsonic ;

    GridLocation_t GridLocation = FaceCenter ;

    IndexRange_t&lt;2&gt; PointRange =
      {{
      int[2] Begin = [1,2] ;
      int[2] End   = [1,6] ;
      }} ;

    !  ListLength = 5
    BCDataSet_t&lt;5&gt; BCDataSet1 =
      {{
      BCTypeSimple_t BCTypeSimple = BCInflowSubsonic ;

      !  Data array length = ListLength = 5
      BCData_t&lt;5&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; EntropyApprox =
          {{
          Data(real, 1, 1) = 0.94 ;
          }} ;

        DataArray_t&lt;real, 1, 1&gt; EnthalpyStagnation =
          {{
          Data(real, 1, 1) = 2.85 ;
          }} ;

        DataArray_t&lt;real, 1, 5&gt; VelocityY =
          {{
          Data(real, 1, 5) = (v_inflow(j), j=3,7) ;
          }} ;
        }} ;
      }} ;
    }} ;
</pre>
This is another example of a <a href="#t:BCTypeSimple">simple
boundary-condition type</a>.
The primary additional complexity included in this example is multiple
Dirichlet conditions with one containing local data.
<tt>DirichletData</tt> contains three
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> entities named
<tt>EntropyApprox</tt>, <tt>EnthalpyStagnation</tt> and <tt>VelocityY</tt>.
This specifies three Dirichlet boundary conditions to be enforced, and
the names identify the solution quantities to set.
Since both <tt>EntropyApprox</tt> and <tt>EnthalpyStagnation</tt> have
an array-length structure parameter of one, they identify global data,
and the values are provided.
<tt>VelocityY</tt> is an array of data values and contains the values in
<tt>v_inflow()</tt>.
The length of the array is given by
<a href="#ListLength"><tt>ListLength</tt></a>, which represents
the number of cell faces because <tt>BC3</tt> is specified using the value
of <tt>FaceCenter</tt> for <tt>GridLocation</tt>.
Note that the beginning and ending indices on the array
<tt>v_inflow()</tt> are unimportant (they are user inputs); there just
needs to be five values provided.

<a name="ex:bc4"></a>
<h4>Example - Outflow</h4>

<p>
Outflow boundary condition with unspecified normal Mach number for an
<i>i</i>-max face of a 3-D structured zone: For subsonic outflow, a uniform
pressure is specified; for supersonic outflow, no boundary-condition
equations are specified.
<pre>
  !  CellDimension = 3, IndexDimension = 3
  BC_t&lt;3,3,3&gt; BC4 =
    {{
    BCType_t BCType = BCOutflow ;

    IndexRange_t&lt;3&gt; PointRange = {{ }} ;

    BCDataSet_t&lt;?&gt; BCDataSetSubsonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCOutflowSubsonic ;

      BCData_t&lt;?&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; Pressure = {{ }} ;
        }} ;
      }} ;

    BCDataSet_t&lt;?&gt; BCDataSetSupersonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCOutflowSupersonic ;
      }} ;
    }} ;
</pre>
This is an example of a <a href="#t:BCTypeCompound">complex
boundary-condition type</a>; the equation set to be enforced depends
on the local flow conditions, namely the Mach number normal to the
boundary.
Two <a href="#BCDataSet">data sets</a> are provided,
<tt>BCDataSetSubsonic</tt> and <tt>BCDataSetSupersonic</tt>; recall
the names are unimportant and are user defined.
The first data set has a boundary-condition type of
<tt>BCOutflowSubsonic</tt> and prescribes a global Dirichlet condition
on static pressure.
Any additional boundary conditions needed may be applied by a flow
solver.
The second data set has a boundary-condition type of
<tt>BCOutflowSupersonic</tt> with no additional boundary-condition equation
specification.
Typically, all solution quantities are extrapolated from the interior
for supersonic outflow.
From the <a href="#t:BCType_assoc">boundary-condition type
association table</a>, <tt>BCOutflow</tt> requires two data sets
with boundary-condition types <tt>BCOutflowSubsonic</tt> and
<tt>BCOutflowSupersonic</tt>.
The accompanying usage rule states that the data set for
<tt>BCOutflowSubsonic</tt> should be used for a subsonic normal Mach number;
otherwise, the data set for <tt>BCOutflowSupersonic</tt> should be enforced.

<p>
Any additional data sets with boundary-condition types other than
<tt>BCOutflowSubsonic</tt> or <tt>BCOutflowSupersonic</tt> could be
provided (the definition of <a href="#BC"><tt>BC_t</tt></a> allows
an arbitrary list of <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>
entities); however, they should be ignored by any code processing the
boundary-condition information.
Another caveat is that providing two data sets with the same simple
boundary-condition type would cause indeterminate results - which one
is the correct data set to apply?

<p>
The actual global data value for static pressure is not provided; an
abbreviated form of the <tt>Pressure</tt> entity is shown.
This example also uses the "<tt>?</tt>" notation for unused
data-array-length structure parameters.

<a name="ex:bc5"></a>
<h4>Example - Farfield</h4>

<p>
Farfield boundary condition with arbitrary flow conditions for a <i>j</i>-max
face of a 2-D structured zone: If subsonic inflow, specify entropy,
vorticity and incoming acoustic characteristics; if supersonic inflow
specify entire flow state; if subsonic outflow, specify incoming
acoustic characteristic; and if supersonic outflow, extrapolate all flow
quantities.
None of the extrapolated quantities for the different boundary condition
possibilities need be stated.
<pre>
  !  CellDimension = 2, IndexDimension = 2
  BC_t&lt;2,2,2&gt; BC5 =
    {{
    BCType_t BCType = BCFarfield ;

    IndexRange_t&lt;2&gt; PointRange = {{ }} ;

    int[2] InwardNormalIndex = [0,-1] ;

    BCDataSet_t&lt;?&gt; BCDataSetInflowSupersonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCInflowSupersonic ;
      }} ;

    BCDataSet_t&lt;?&gt; BCDataSetInflowSubsonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCInflowSubsonic ;

      BCData&lt;?&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; CharacteristicEntropy      = {{ }} ;
        DataArray_t&lt;real, 1, 1&gt; CharacteristicVorticity1   = {{ }} ;
        DataArray_t&lt;real, 1, 1&gt; CharacteristicAcousticPlus = {{ }} ;
        }} ;
      }} ;

    BCDataSet_t&lt;?&gt; BCDataSetOutflowSupersonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCOutflowSupersonic ;
      }} ;

    BCDataSet_t&lt;?&gt; BCDataSetOutflowSubsonic =
      {{
      BCTypeSimple_t BCTypeSimple = BCOutflowSubsonic ;

      BCData&lt;?&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; CharacteristicAcousticMinus = {{ }} ;
        }} ;
      }} ;
    }} ;
</pre>
The farfield boundary-condition type is the most complex of the
<a href="#t:BCTypeCompound">compound boundary-condition types</a>.
<tt>BCFarfield</tt> requires four <a href="#BCDataSet">data sets</a>;
these data sets must contain the <a href="#t:BCTypeSimple">simple
boundary-condition types</a> <tt>BCInflowSupersonic</tt>,
<tt>BCInflowSubsonic</tt>, <tt>BCOutflowSupersonic</tt> and
<tt>BCOutflowSubsonic</tt>.
This example provides four appropriate data sets.
The <a href="#t:BCType_assoc">usage rule given for <tt>BCFarfield</tt></a>
states which set of boundary-condition equations to be enforced based on the
normal velocity and normal Mach number.

<p>
The data set for supersonic-inflow provides no information other than
the <a href="#BCType">boundary-condition type</a>.
A flow solver is free to apply any conditions that are appropriate;
typically all solution quantities are set to freestream reference state
values.
The data set for subsonic-inflow states that three Dirichlet conditions
should be enforced; the three data identifiers provided are from the
standard <a href="dataname.html">data-name identifier conventions</a>.
The data set for supersonic-outflow only provides the boundary-condition
type, and the data set for subsonic-outflow provides one
Dirichlet condition on the incoming acoustic characteristic,
<tt>CharacteristicAcousticMinus</tt>.

<p>
Also provided in the example is the inward-pointing
computational-coordinate normal; the normal points in the -<i>j</i>
direction, meaning the BC patch is a <i>j</i>-max face.
This information could also be obtained from the BC patch description
given in <tt>IndexRange</tt>.

<p>
Note that this example shows only the overall layout of the
boundary-condition entity.
<a href="build.html#IndexRange"><tt>IndexRange</tt></a> and all
<a href="data.html#DataArray"><tt>DataArray_t</tt></a> entities
are abbreviated, and all unused structure functions are not evaluated.

<a name="ex:bc6"></a>
<h4>Example - Viscous Solid Wall II</h4>

<p>
There are circumstances when a user may wish to define a BC patch using
vertices (under <a href="#BC"><tt>BC_t</tt></a>), but store the BC data
at face centers (under <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>).
The following example is similar to the <a href="#ex:bc6">Viscous Solid
Wall</a> example given previously, with the exception that the Dirichlet
data for temperature is stored at face centers rather than at vertices.

<p>
As before, the example is a viscous solid wall in a 3-D structured
zone, where a Dirichlet condition is enforced for temperature; the wall
temperature for the entire wall is specified to be 273 K.
The BC patch is on the <i>j</i>-min face and is bounded by the indices
(1,1,1) and (33,1,9).
<pre>
  !  CellDimension = 3, IndexDimension = 3
  BC_t&lt;3,3,3&gt; BC2 =
    {{
    BCType_t BCType = BCWallViscousIsothermal ;

    !  Grid location is Vertex by default
    IndexRange_t&lt;3&gt; PointRange =
      {{
      int[3] Begin = [1 ,1,1] ;
      int[3] End   = [33,1,9] ;
      }} ;

    !  ListLength = 33*9 = 297
    BCDataSet_t&lt;297&gt; BCDataSet1 =
      {{
      BCTypeSimple_t BCTypeSimple = BCWallViscousIsothermal ;

      GridLocation_t GridLocation = FaceCenter ;
      IndexRange_t&lt;3&gt; PointRange =
        {{
        int[3] Begin = [1 ,1,1] ;
        int[3] End   = [32,1,8] ;
        }} ;

      !  ListLength = 32*8 = 256
      BCData_t&lt;256&gt; DirichletData =
        {{
        DataArray_t&lt;real, 1, 1&gt; Temperature =
          {{
          Data(real, 1, 1) = 273. ;

          DataClass_t DataClass = Dimensional ;

          DimensionalUnits_t DimensionalUnits =
            {{
            MassUnits        = MassUnitsNull ;
            LengthUnits      = LengthUnitsNull ;
            TimeUnits        = TimeUnitsNull ;
            TemperatureUnits = Kelvin ;
            AngleUnits       = AngleUnitsNull ;
            }} ;
          }} ;
        }} ;
      }} ;
    }} ;
</pre>

<p>
As in the previous <a href="#ex:bc6">Viscous Solid Wall</a> example,
although the boundary-condition data is global, we include in this
example structure parameters that are the lengths of potential
local-data arrays.
In <a href="#BC"><tt>BC_t</tt></a>, <tt>GridLocation</tt> is not
specified, and thus is <tt>Vertex</tt> by default.
The structure function <a href="#ListLength"><tt>ListLength</tt></a> is
297, based on the specification of <tt>PointRange</tt>, and that value
is passed to <a href="#BCDataSet"><tt>BCDataSet_t</tt></a>.

<p>
In this example <tt>PointRange</tt> is specified in <tt>BCDataSet_t</tt>,
so the <tt>ListLength</tt> passed into it from <tt>BC_t</tt> is not used.
In <tt>BCDataSet_t</tt>, <tt>GridLocation</tt> is specified as
<tt>FaceCenter</tt>, and <tt>PointRange</tt> is set accordingly.
The corresponding value of <tt>ListLength</tt> is 256, which is passed
into <a href="#BCData"><tt>BCData_t</tt></a>.

<p>
As before, in <tt>BCData_t</tt> the entity <tt>Temperature</tt> contains
global data, so the value of <tt>ListLength</tt> is unused.

<p>
<hr size=4 width=75%>
<div class=footer>
<!--#include virtual="../include/footer_small.html" -->
Last updated 15 Feb 2013

</body>
</html>
